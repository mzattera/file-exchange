You are an agent assisting a developer in translating some Java code into Python.
The Java code is provided below, in <java> tag.

Your task is to translate UpdatePoATool Java class into Python; while you do it, you **MUST** **STRICTLY** follow the instructions below.

## Instructions

Some of the Java classes have already been translated into Python and they are provided in the <python> tag. If you need access to these class, provide the proper import directives in your Python code and assume the classes will be available; **STRICTLY** never use minimal fallback code.

Java comments might contain directions about how to translate code in Python;  **STRICTLY** follow them if they are provided.

Be aware that the Java code uses Lombok annotations; you need to translate code generated by Lombok as well.Read the code in <java> carefully before translating it into Python.

When translating Java fields and methods into Python, use proper naming convention (e.g. translate field names from camelCase into snake_case).

Always use type annotations (Python 3.6+).

When @NonNull is used in a method parameter, add code in the Python function that checks provided parameter value is not null.

Ignore the "final" attribute when converting from Java.

Translate RuntimeException as RuntimeError and IllegalArgumentException as ValueError.

**STRICTLY** always create comments in English; **NEVER** use Italian in your output.

**STRICTLY** ignore @JsonView annotation when translating into Python; behave like it is not there

### Logging

Java code uses Java libraries for logging (e.g. slf4j); when translating code to Python translate this by using equivalent methods in the logging standard library. For example:

```java
public class Agent {

	private final static Logger LOG = LoggerFactory.getLogger(Agent.class);

	...LOG.debug("Message");
```

Must be translated into somethign like:

```python
import logging

# configurationequivalent to Java SimpleLogger
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)

logger = logging.getLogger(__name__)  # as LoggerFactory.getLogger()

...


logger.debug("Message")

```



### Constructors

When translating Java overloaded constructors (which Python does not support), use one flexible __init__ plus a couple of convenience class-methods. This keeps the call-sites as short as in Java while complying with Python best-practice (PEP 8 naming, type hints, single source of truth).

For example, the below list of constructors for same class:

```java
public ChatMessage(String content) {
	this(Author.USER, content);
}

public ChatMessage(@NonNull MessagePart part) {
	this(Author.USER, part);
}

public ChatMessage(@NonNull List<? extends MessagePart> parts) {
	this(Author.USER, parts);
}

public ChatMessage(@NonNull Author author, String content) {
	this.author = author;
	if (content != null)
		parts.add(new TextPart(content));
}

public ChatMessage(@NonNull Author author, @NonNull MessagePart part) {
	this.author = author;
	this.parts.add(part);
}

public ChatMessage(@NonNull Author author, @NonNull List<? extends MessagePart> parts) {
	this.author = author;
	this.parts.addAll(parts);
}
```

Must be translated as:

```python
from __future__ import annotations
from collections.abc import Sequence
from typing import overload

class Author(str):
    USER = "user"
    SYSTEM = "system"
    # …

class MessagePart: ...
class TextPart(MessagePart):
    def __init__(self, content: str) -> None:
        self.content = content


class ChatMessage:
    """
    A port of the Java `ChatMessage` with the same semantics.

    Parameters
    ----------
    author : Author, default Author.USER
    parts  : • str                → wrapped in TextPart
             • MessagePart        → stored as-is
             • Sequence[MessagePart] → copied 1-to-1
    """
    # static type-checkers can still benefit from @overload
    @overload
    def __init__(self, content: str, author: Author = Author.USER) -> None: ...
    @overload
    def __init__(self, part: MessagePart, author: Author = Author.USER) -> None: ...
    @overload
    def __init__(
        self,
        parts: Sequence[MessagePart],
        author: Author = Author.USER,
    ) -> None: ...

    def __init__(
        self,
        first: str | MessagePart | Sequence[MessagePart],
        author: Author = Author.USER,
    ) -> None:
        self.author: Author = author
        self.parts: list[MessagePart] = []

        ##### --- normalise input -------------------------------------------------
        if isinstance(first, str):
            self.parts.append(TextPart(first))
        elif isinstance(first, MessagePart):
            self.parts.append(first)
        else:  # sequence of parts
            self.parts.extend(first)
        ##### ---------------------------------------------------------------------

    ##### ---------- alternate constructors (optional) ---------------------------
    @classmethod
    def from_content(cls, content: str, author: Author = Author.USER) -> "ChatMessage":
        return cls(content, author)

    @classmethod
    def from_part(cls, part: MessagePart, author: Author = Author.USER) -> "ChatMessage":
        return cls(part, author)
```

### Builder

The provided Java classes often use the Builder pattern either providing a Builder explicitly or using @Builder Lombok annotation.
In all of these cases, strictly use a “fluent interface” style pattern.

For example, this Java class:

```java
import lombok.Builder;
import lombok.Singular;
import lombok.Value;
import java.util.List;

@Builder             
public class PizzaOrder {

    @Builder.Default
    String size = "M";          

    @Singular
    List<String> toppings;      

    @Builder.Default
    boolean glutenFree = false; 
}
```

Must be translated in Python as follows:


```python
from dataclasses import dataclass, field
from typing import Self

@dataclass
class PizzaOrder:
    size: str = "M"
    toppings: list[str] = field(default_factory=list)
    gluten_free: bool = False

    # “fluent interface” style
    def with_size(self, size: str) -> Self:
        self.size = size
        return self

    def add_topping(self, name: str) -> Self:
        self.toppings.append(name)
        return self
```

### Getters and setters

Do not  translate literally java getters and setters in Python, rather follow the below logic:

  1. If no getter or setter is provided, make the field private using "_underscore naming"
  2. If any getter or setter is provided with Lombok annotations that is not private, then treat corresponding field as public in Python and give it direct attribute access. Do this regardless the access level for the getter/setter (e.g. if the getter is public and the setter is protected, treat the field as public).
  3. If any getter or setter is provided in Java with some logic, then use @property annotation in Python and translate corresponding Java logic.
  
When @NonNull is used in a class field, create a @property setter in Python that checks provided value is not null (None).
  

### Interfaces and Abstract classes

The Java code often uses an interface+abstract class pattern: typically there is an interface I and an abstract class AI that implements I, with the purpose to have developers extend AI for actual implementations of I; this also to allow Java classes to extend multiple interfaces whilst providing some boiler plate code in abstract classes.

An example of this pattern are the Tool and AbstractTool:

```java
public interface Tool {
	String getId();
	String getDescription();
	boolean isClosed();	
	void init(Agent agent);
	...other interface methods
}

public abstract class AbstractTool implements Tool {

	@Getter
	private final String id;

	@Getter
	private String description = "";

	@Getter
	@Setter(AccessLevel.PROTECTED)
	private boolean closed = false;
	
	@Override
	public void init(@NonNull Agent agent) {
		...implements init()
	}
}

public class MyTool extends AbstractTool implements Closeable {
	...
}
```

In Python this must be translated with a similar pattern, as shown below. Notice that the Tool interface defines getters as interface methods, but we have a 6rule to translate those into publicly accessible fields in Python

```python
from abc import ABC, abstractmethod
from typing import Protocol


class Tool(ABC):
    """Python equivalent of a Java interface, note getters are replaced with publicly accessible fields."""
    id: str
    description: str

    @abstractmethod
    def init(self, agent: "Agent") -> None: ...
    # ...other interface methods.


class AbstractTool(Tool):
    """Python equivalent of the Java abstract class"""
    def __init__(self, id_: str, description: str) -> None:
        self.id: str = id_
        self.description: str = description
        self.closed: bool = False

    def init(self, agent: "Agent") -> None:
        # ...implements init()


class MyTool(AbstractTool, Closeable):

    def close(self) -> None:
        # ...from Closeable
```

### JSON schema and serialisation

The Java class `JsonShema` is only meant to provide static methods to:

  1. Obtain a JSON schema from a class.
  2. Serialise an instance of a class into JSON.
  3. De-serialise the JSON representation of a class.
  
For 1. the class relies on Jackson annotations; an example is provided below.

Given this class annotated with Jackson annotations:

```java
@JsonSchemaDescription("This is a class describing parameters for GetCurrentWeatherTool")
public static class Parameters {

	private enum TemperatureUnits {
		CELSIUS, FARENHEIT
	};

	@JsonProperty(required = true)
	@JsonPropertyDescription("The city and state, e.g. San Francisco, CA.")
	public String location;

	@JsonPropertyDescription("Temperature unit (CELSIUS or FARENHEIT), defaults to CELSIUS")
	public TemperatureUnits unit;
}
```

Calling `JsonSchema.getJsonSchema(Parameters.class)` will return the following:

```
{"$schema":"http://json-schema.org/draft-04/schema#","title":"Parameters","type":"object","additionalProperties":false,"description":"This is a class describing parameters for GetCurrentWeatherTool","properties":{"location":{"type":"string","description":"The city and state, e.g. San Francisco, CA."},"unit":{"type":"string","enum":["CELSIUS","FARENHEIT"],"description":"Temperature unit (CELSIUS or FARENHEIT), defaults to CELSIUS"}},"required":["location"]}
```

When translating JsonSchema into Python, it is expected that pydantic and its annotations are used to generate an exact JSON schema like the above.

When translating Java classes into Python strictly ensure Jackson annotations are replaced with corresponding Pydantic ones.

<java>

## UpdatePoATool.java

/**
 * 
 */
package com.infosys.small.pnbc;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.infosys.small.core.Agent;
import com.infosys.small.core.JsonSchema;
import com.infosys.small.core.ToolCall;
import com.infosys.small.core.ToolCallResult;
import com.infosys.small.pnbc.Peace.Person;
import com.infosys.small.react.ReactAgent;

import lombok.NonNull;

/**
 * This is a tool used to check SKS and PoA documents and update client
 * information accordingly, as a sub-task.
 */
public class UpdatePoATool extends LabAgent {

	// I want to force specific processing, not generic commands
	public static class Parameters extends ReactAgent.Parameters {

		@JsonProperty(required = true)
		@JsonPropertyDescription("Unique Client Number for the estate.")
		public String estateCustomerNumber;
	}

	// I want to force specific processing, not generic commands
	private static final String COMMAND = "Retrieve Probate Certificate (SKS) and Power of Attorney (PoA) documents for estate with Customer Number=\"{{estate}}\", if available.\n" //
			+ "IF none of the SKS or PoA are provided, THEN end execution.\n"
			+ "Meticulously compare all information available about the persons related to the estate with corresponding data provided in both SKS or PoA documents "
			+ "(e.g. check whether email addresses in PoA or SKS is different from that in our systems); "
			+ "in this step, **STRICTLY** ignore \"Power Of Attorney Type\" and \"Identification Completed\" fields but be very mindful with other fields, "
			+ "including relation to estate if different than \"Other\" (e.g. if you can infer from SKS or PoA a person is now \"Heir\"). " //
			+ "IF AND ONLY IF you find any data that is missing or that needs to be updated (considering above exceptions), THEN update the record for the related person, "
			+ "ELSE do not make any attempt to write, confirm, or update the person's data.\n" //
			+ "\n" //

			+ "IF PoA is available, THEN {\n"
			+ "	FOR EACH person who (has received some power of attorney in PoA other than \"None\") AND (hasn't only granted power of attorney to somebody in PoA) {\n"
			+ "		IF the person has any account in the bank THEN {\n" //
			+ "			Update person's \"Power Of Attorney Type\" and \"Relation To Estate\" accordingly to PoA and set \"Identification Completed\"=\"OK - Client\".\n" //
			+ "			Unblock accounts for the estate.\n" //
			+ "			In your output, notify the user that accounts for estate have been unblocked; provide estate's Customer Number.\n" //
//			+ "			Create an entry in the task diary with category \"Created netbank to CPR\" mentioning that accounts for given estate have been unblocked; provide the estate's Customer Number.\n" //
			+ "		}\n" //
			+ "		IF the person does NOT have any account in the bank THEN {\n" //
			+ "			Communicate to the Operations Officer that that person cannot be identified; clearly specify the power of attorney type they received. End the process execution here.\n" //
			+ "		}\n" //
			+ "	}\n" // For each person
			+ "}\n"; // IF PoA was provided

	public UpdatePoATool() {

		super("updatePoATool", //
				"This tool processes the Probate Certificate (SKS) and Power of Attorney (PoA) documents to perform any required update of client data. "
						+ "**STRICTLY** use this only to process Probate Certificate (SKS) and Power of Attorney (PoA) documents.",
				List.of( //
						new Peace(), //
						new CustomerPortal(), //
						new OperatorCommunicationTool(), //
						new FileDownloadTool() //
				));

		this.getExecutor().setCheckLastStep(true);

		// We want this to have clear parameters definition when invoked and we do not
		// need a command, as we have it already.
		setJsonParameters(Parameters.class);

		setContext(
				"  * Documents you handle are in Danish, this means sometime you have to translate tool calls parameters. For example, \"Customer Number\" is sometimes indicated as \"afdøde CPR\" or \"CPR\" in documents.\n"
						+ "  * Probate Certificate is a document that lists heirs for one estate; it is sometime indicated as \"SKS\".\n"
						+ "  * Power of Attorney document (PoA) is a document that define people's legal rights over the estate's asset. It is sometime indicated as \"PoA\".\n"

						+ "  * Data about persons related to estates are described by the below JSON schema:\n" //
						+ JsonSchema.getJsonSchema(Person.class) + "\n" //
						+ "  * Persons are uniquely identified by their Customer Number, sometimes also referred as CPR. Always provide the Customer Number if a tool needs to act on a specific person/client; indicate it as Customer Number and not CPR when passing it to tools.\n");
	}

	@Override
	public ToolCallResult invoke(@NonNull ToolCall call) throws Exception {
		if (!isInitialized())
			throw new IllegalStateException("Tool must be initialized.");

		String estate = getString("estateCustomerNumber", call.getArguments());
		if (estate == null)
			return new ToolCallResult(call, "ERROR: You must provide the estate's Customer Number.");

		Map<String, String> map = new HashMap<>();
		map.put("estate", estate);

		ExecutionContext ctx = getLabAgent().getExecutionContext();
		Step result = execute(ctx, Agent.fillSlots(COMMAND, map));
		switch (result.status) {
		case ERROR:
			return new ToolCallResult(call, "ERROR: " + result.observation);
		default:
			return new ToolCallResult(call, result.observation);
		}
	}
}
</java>

<python>

## agent.py

"""agent.py

Python translation of the Java `Agent` class.

The implementation mirrors the original behaviour while embracing Pythonic
conventions and the `openai` Python SDK.
"""

from __future__ import annotations

import json
import logging
import os
from collections.abc import Iterable, Sequence
from typing import Any, Dict, List, Mapping, MutableMapping, Type

import openai

from chat_types import (
    ChatCompletion,
    ChatMessage,
    TextPart,
    ToolCall,
    ToolCallResult,
)
from json_schema import JsonSchema
from tool import Tool

##### --------------------------------------------------------------------------- #
##### Logging
##### --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

##### --------------------------------------------------------------------------- #
##### Agent
##### --------------------------------------------------------------------------- #
class Agent:
    """
    An *Agent* that uses OpenAI’s Chat Completions API.

    Parameters
    ----------
    id_ : str
        Unique identifier for the agent.
    description : str
        Human-readable description of the agent’s capabilities.
    tools : Iterable[Tool], optional
        Tools that the agent can invoke.
    """

    DEFAULT_MODEL: str = "gpt-4.1"

    ##### -------------------------- construction --------------------------- #
    def __init__(
        self,
        id_: str = "OpenAIChatCompletionService",
        description: str = "Test agent",
        tools: Iterable[Tool] | None = None,
    ) -> None:
        if id_ is None:
            raise ValueError("id_ must not be None")
        if description is None:
            raise ValueError("description must not be None")

        self.id: str = id_
        self.description: str = description

        # Tools --------------------------------------------------------- #
        self._tool_map: Dict[str, Tool] = {}
        for tool in tools or []:
            if tool is None:
                raise ValueError("tools must not contain None")
            tool.init(self)
            self._tool_map[tool.id] = tool

        # Conversation state ------------------------------------------- #
        self.history: List[ChatMessage] = []
        self.max_history_length: int = float("inf")  # no hard limit
        self.max_conversation_steps: int = float("inf")

        # Model configuration ------------------------------------------ #
        self.model: str = self.DEFAULT_MODEL
        self.temperature: float = 0.0
        self.personality: str | None = None
        self._response_format: str | None = None

        # OpenAI configuration ----------------------------------------- #
        # Expect OPENAI_API_KEY in the environment
        openai.api_key = os.getenv("OPENAI_API_KEY")

    ##### --------------------------- utils -------------------------------- #
    # Conversation helpers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    def clear_conversation(self) -> None:
        """Start a new chat (clears stored history)."""
        self.history.clear()

    # Personality / response-format ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    @property
    def response_format(self) -> str | None:
        return self._response_format

    def set_response_format(self, schema: Type) -> None:
        """Define an explicit JSON schema for model outputs."""
        if schema is None:
            raise ValueError("schema must not be None")
        self._response_format = JsonSchema.get_json_schema(schema)

    ##### --------------------- public chat API ---------------------------- #
    def chat(self, message: str | ChatMessage | Sequence[ChatMessage]) -> ChatCompletion:
        """
        Continue the ongoing conversation with *message*.

        The provided message(s) are appended to the conversation, the LLM is
        queried, and the reply is stored in the history.
        """
        # Normalise input
        if isinstance(message, str):
            new_messages = [ChatMessage(message)]
        elif isinstance(message, ChatMessage):
            new_messages = [message]
        else:
            new_messages = list(message)

        # Build conversation context
        conversation: List[ChatMessage] = list(self.history) + new_messages
        self._trim_conversation(conversation)

        # Call the model
        completion = self._chat_completion(conversation)

        # Update history (respecting max_history_length)
        self.history.extend(new_messages)
        self.history.append(completion.message)
        if len(self.history) > self.max_history_length:
            del self.history[: len(self.history) - self.max_history_length]

        return completion

    ##### ------------------------------------------------------------------ #
    # One-shot completion (ignores history) ---------------------------- #
    def complete(self, prompt: str | ChatMessage) -> ChatCompletion:
        """Run *prompt* outside the conversation (history is untouched)."""
        single = ChatMessage(prompt) if isinstance(prompt, str) else prompt
        conversation = [single]
        self._trim_conversation(conversation)
        return self._chat_completion(conversation)

    ##### -------------------------- internals ----------------------------- #
    # Trim conversation to honour limits and add personality ~~~~~~~~~~~ #
    def _trim_conversation(self, messages: List[ChatMessage]) -> None:
        """Mutate *messages* so it respects configured limits."""
        # Remove leading tool-results without matching calls
        while messages and messages[0].has_tool_call_results():
            messages.pop(0)

        # Enforce max steps
        if len(messages) > self.max_conversation_steps:
            del messages[: len(messages) - self.max_conversation_steps]

        if not messages:
            raise ValueError("No messages left in conversation after trimming")

        # Inject personality (developer role) as first message
        if self.personality:
            messages.insert(0, ChatMessage(self.personality, ChatMessage.Author.DEVELOPER))

    # Convert ChatMessage → OpenAI message dict ~~~~~~~~~~~~~~~~~~~~~~~~ #
    def _from_chat_message(self, msg: ChatMessage) -> List[Dict[str, Any]]:
        if msg.has_tool_calls():
            tool_calls = []
            for call in msg.get_tool_calls():
                tool_calls.append(
                    {
                        "id": call.id,
                        "type": "function",
                        "function": {
                            "name": call.tool.id,
                            "arguments": json.dumps(call.arguments, separators=(",", ":")),
                        },
                    }
                )
            return [{"role": "assistant", "content": None, "tool_calls": tool_calls}]

        if msg.has_tool_call_results():
            return [
                {
                    "role": "tool",
                    "tool_call_id": r.tool_call_id,
                    "content": r.result,
                }
                for r in msg.get_tool_call_results()
            ]

        # Plain text
        if not msg.is_text():
            raise ValueError("Message must be text, a tool call, or tool call results")

        role_map = {
            ChatMessage.Author.USER: "user",
            ChatMessage.Author.BOT: "assistant",
            ChatMessage.Author.DEVELOPER: "system",  # OpenAI 'developer' maps to 'system'
        }
        return [{"role": role_map[msg.author], "content": msg.get_text_content()}]

    # Convert OpenAI message → ChatMessage ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    def _from_openai_message(self, message: Mapping[str, Any]) -> ChatMessage:
        if "tool_calls" in message:
            calls: List[ToolCall] = []
            for tc in message["tool_calls"]:
                tool_id = tc["function"]["name"]
                tool = self._tool_map.get(tool_id)
                if tool is None:
                    raise ValueError(f"No tool registered with id '{tool_id}'")

                calls.append(
                    ToolCall(
                        id_=tc["id"],
                        tool=tool,
                        arguments=json.loads(tc["function"]["arguments"]),
                    )
                )
            return ChatMessage(ChatMessage.Author.BOT, calls)

        parts: List[TextPart] = []
        if content := message.get("content"):
            parts.append(TextPart(str(content)))
        if message.get("role") == "assistant" and message.get("content") is None:
            parts.append(TextPart("**The model generated an empty response**"))

        return ChatMessage(ChatMessage.Author.BOT, parts)

    # Prepare response_format / tools for OpenAI call ~~~~~~~~~~~~~~~~~~ #
    def _create_response_format(self) -> Dict[str, Any] | None:
        if self._response_format is None:
            return None
        return {
            "type": "json_object",
            "schema": json.loads(self._response_format),
        }

    def _create_tool_definitions(self) -> List[Dict[str, Any]] | None:
        if not self._tool_map:
            return None
        tools = []
        for t in self._tool_map.values():
            tools.append(
                {
                    "type": "function",
                    "function": {
                        "name": t.id,
                        "description": t.description,
                        "parameters": json.loads(t.json_parameters),
                    },
                }
            )
        return tools

    # Core: call OpenAI and wrap result ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    def _chat_completion(self, messages: Sequence[ChatMessage]) -> ChatCompletion:
        openai_messages: List[Dict[str, Any]] = []
        for m in messages:
            openai_messages.extend(self._from_chat_message(m))

        req: Dict[str, Any] = {
            "model": self.model,
            "messages": openai_messages,
            "temperature": self.temperature,
        }

        if (rf := self._create_response_format()) is not None:
            req["response_format"] = rf
        if (td := self._create_tool_definitions()) is not None:
            req["tools"] = td

        logger.info("OpenAI request: %s", req)

        resp = openai.ChatCompletion.create(**req)
        choice = resp.choices[0]
        finish_reason = self._map_finish_reason(choice.finish_reason)

        chat_message = self._from_openai_message(choice.message)
        return ChatCompletion(finish_reason, chat_message)

    # Finish-reason mapping ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    @staticmethod
    def _map_finish_reason(finish: str | None) -> ChatCompletion.FinishReason:
        mapping = {
            "stop": ChatCompletion.FinishReason.COMPLETED,
            "tool_calls": ChatCompletion.FinishReason.COMPLETED,
            "function_call": ChatCompletion.FinishReason.COMPLETED,
            "length": ChatCompletion.FinishReason.TRUNCATED,
            "content_filter": ChatCompletion.FinishReason.INAPPROPRIATE,
        }
        return mapping.get(finish, ChatCompletion.FinishReason.OTHER)

	# Finish-reason mapping ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #      
    @staticmethod
    def fill_slots(template: str, slots: Mapping[str, Any]) -> str:  
        """
        Replace every ``{{key}}`` in *template* with the corresponding value
        from *slots*. Unknown keys are left untouched; *None* is replaced by
        the empty string.

        Parameters
        ----------
        template : str
            A string containing ``{{placeholders}}``.
        slots : Mapping[str, Any]
            Values to inject into the template.

        Returns
        -------
        str
            The rendered string.
        """
        if template is None:
            raise ValueError("template must not be None")
        if slots is None:
            raise ValueError("slots must not be None")

        def _sub(match: re.Match[str]) -> str:
            key = match.group(1).strip()
            value = slots.get(key)
            return "" if value is None else str(value)

        return re.sub(r"\{\{([^}]+)\}\}", _sub, template)
        
    ##### --------------------------- teardown ----------------------------- #
    def close(self) -> None:
        """Close all tools; nothing required for *openai* client."""
        for tool in self._tool_map.values():
            try:
                tool.close()
            except Exception:  # noqa: BLE001
                logger.exception("Error while closing tool %s", tool.id)


## chat_types.py

"""chat_types.py

Auto‑generated Python translation of several Java classes:

- ChatCompletion
- ChatMessage (+ nested Author)
- MessagePart (interface)
- TextPart
- ToolCall (with fluent Builder)
- ToolCallResult
- FinishReason (nested in ChatCompletion)

The implementation follows the translation guidelines supplied:
* CamelCase → snake_case for identifiers.
* Lombok‑generated boiler‑plate is made explicit.
* Overloaded constructors mapped to a single __init__ with @overload helpers.
* Builder patterns translated into fluent interfaces.
* Java RuntimeException / IllegalArgumentException mapped to Python RuntimeError / ValueError.
* Logging uses Python’s stdlib 'logging' module.
* JSON (de)serialisation leverages the provided JsonSchema helper.

The module purposefully contains **no** external side‑effects.
"""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from collections.abc import Sequence
from typing import Any, Mapping, overload, Self, Type, TypeVar

from json_schema import JsonSchema

##### Forward‑references to avoid circular imports at type‑checking time
if False:  # pragma: no cover
    from agent import Agent
    from tool import Tool  # AbstractTool & Tool live in the project
    from tool_call_result import ToolCallResult  # noqa: F401

##### --------------------------------------------------------------------------- #
##### Logging configuration (equivalent to Java SimpleLogger)
##### --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

##### --------------------------------------------------------------------------- #
##### MessagePart – marker interface
##### --------------------------------------------------------------------------- #
class MessagePart(ABC):
    """A piece of a :class:`ChatMessage`."""

    @abstractmethod
    def get_content(self) -> str:
        """Return a textual representation of this part (best‑effort)."""

    ##### ------------------------------------------------------------------ #
    # Pythonic alias
    ##### ------------------------------------------------------------------ #
    def __str__(self) -> str:  # pragma: no cover
        return self.get_content()


##### --------------------------------------------------------------------------- #
##### TextPart – simple textual message part
##### --------------------------------------------------------------------------- #
class TextPart(MessagePart):
    """A :class:`MessagePart` containing plain text."""

    def __init__(self, content: str) -> None:
        if content is None:
            raise ValueError("content must not be None")
        self._content: str = str(content)

    # Property to honour @NonNull semantics
    @property
    def content(self) -> str:
        return self._content

    @content.setter
    def content(self, value: str) -> None:
        if value is None:
            raise ValueError("content must not be None")
        self._content = str(value)

    # MessagePart ------------------------------------------------------ #
    def get_content(self) -> str:
        return self._content


##### --------------------------------------------------------------------------- #
##### ToolCall – a single invocation of a Tool
##### --------------------------------------------------------------------------- #
class ToolCall(MessagePart):
    """Represents a single invocation of a :class:`Tool`."""

    def __init__(
        self,
        id_: str,
        tool: "Tool",
        arguments: Mapping[str, Any] | None = None,
    ) -> None:
        if id_ is None:
            raise ValueError("id_ must not be None")
        if tool is None:
            raise ValueError("tool must not be None")

        self.id: str = id_
        self.tool: "Tool" = tool
        self.arguments: dict[str, Any] = dict(arguments or {})

    ##### ----------------------- builder helpers -------------------------- #
    class Builder:
        """Fluent builder replicating the Java pattern."""

        def __init__(self) -> None:
            self._id: str | None = None
            self._tool: "Tool | None" = None
            self._arguments: dict[str, Any] = {}

        # id
        def id(self, id_: str) -> Self:  # noqa: D401 (“Returns self”)
            if id_ is None:
                raise ValueError("id must not be None")
            self._id = id_
            return self

        # tool
        def tool(self, tool: "Tool") -> Self:  # noqa: D401
            if tool is None:
                raise ValueError("tool must not be None")
            self._tool = tool
            return self

        # arguments – mapping
        def arguments(self, args: Mapping[str, Any]) -> Self:  # noqa: D401
            if args is None:
                raise ValueError("args must not be None")
            self._arguments = dict(args)
            return self

        # arguments – JSON string
        def arguments_json(self, json_str: str) -> Self:  # noqa: D401
            from typing import TypeAlias
            import json as _json

            _Map: TypeAlias = dict[str, Any]
            self._arguments = JsonSchema.deserialize(json_str, _Map)  # type: ignore[type-var]
            return self

        # Build
        def build(self) -> "ToolCall":
            return ToolCall(
                id_=self._id or (lambda: (_ for _ in ()).throw(ValueError("id not set")))(),  # trick to raise
                tool=self._tool or (lambda: (_ for _ in ()).throw(ValueError("tool not set")))(),
                arguments=self._arguments,
            )

    # Mimic Java's static builder() method
    @staticmethod
    def builder() -> "ToolCall.Builder":
        return ToolCall.Builder()

    ##### ------------------------------------------------------------------ #
    # MessagePart
    ##### ------------------------------------------------------------------ #
    def get_content(self) -> str:
        return f"ToolCall(id={self.id}, tool={self.tool.id}, args={self.arguments})"

    ##### ------------------------------------------------------------------ #
    # Execution helper
    ##### ------------------------------------------------------------------ #
    def execute(self) -> "ToolCallResult":
        """Invoke the underlying tool and return its result."""
        if self.tool is None:
            raise RuntimeError("Cannot execute a ToolCall without a bound Tool")
        return self.tool.invoke(self)  # type: ignore[return-value]


##### --------------------------------------------------------------------------- #
##### ToolCallResult – holds the outcome of a ToolCall
##### --------------------------------------------------------------------------- #
class ToolCallResult(MessagePart):
    """Result (or error) produced by a :class:`ToolCall`."""

    def __init__(
        self,
        tool_call_id: str,
        tool_id: str,
        result: str | None = None,
        is_error: bool = False,
    ) -> None:
        if tool_call_id is None:
            raise ValueError("tool_call_id must not be None")
        if tool_id is None:
            raise ValueError("tool_id must not be None")

        self.tool_call_id: str = tool_call_id
        self.tool_id: str = tool_id
        self.result: str | None = result
        self.is_error: bool = is_error

    # Convenience constructors matching Java behaviour ----------------- #
    @classmethod
    def from_call(cls, call: ToolCall, result: str | None) -> "ToolCallResult":
        return cls(call.id, call.tool.id, result)

    @classmethod
    def from_exception(cls, call: ToolCall, exc: Exception) -> "ToolCallResult":
        return cls(call.id, call.tool.id, f"Error: {exc}", is_error=True)

    ##### ------------------------------------------------------------------ #
    # MessagePart
    ##### ------------------------------------------------------------------ #
    def get_content(self) -> str:
        label = "*ERROR* " if self.is_error else ""
        body = "" if self.result is None else str(self.result)
        return f"ToolCallResult({label}{body})"


##### --------------------------------------------------------------------------- #
##### ChatMessage – exchanged between user and agent
##### --------------------------------------------------------------------------- #
class ChatMessage:
    """A single chat message, possibly composed of multiple parts."""

    ##### --------------------------- author -------------------------------- #
    class Author(str):
        """Enumeration of possible message authors."""

        USER = "user"
        BOT = "bot"
        DEVELOPER = "developer"

        def __new__(cls, value: str):
            return str.__new__(cls, value)

    ##### ------------------------- construction ---------------------------- #
    @overload
    def __init__(self, content: str, author: "ChatMessage.Author" = Author.USER) -> None: ...
    @overload
    def __init__(self, part: MessagePart, author: "ChatMessage.Author" = Author.USER) -> None: ...
    @overload
    def __init__(
        self,
        parts: Sequence[MessagePart],
        author: "ChatMessage.Author" = Author.USER,
    ) -> None: ...

    def __init__(
        self,
        first: str | MessagePart | Sequence[MessagePart],
        author: "ChatMessage.Author" = Author.USER,
    ) -> None:
        if author is None:
            raise ValueError("author must not be None")

        self.author: ChatMessage.Author = author
        self.parts: list[MessagePart] = []

        # Normalise input
        if isinstance(first, str):
            self.parts.append(TextPart(first))
        elif isinstance(first, MessagePart):
            self.parts.append(first)
        else:  # iterable of parts
            self.parts.extend(first)

    ##### ------------------------------------------------------------------ #
    # Public helpers (mirroring Java API)
    ##### ------------------------------------------------------------------ #
    def is_text(self) -> bool:
        """Return *True* iff every part is a :class:`TextPart`."""
        return all(isinstance(p, TextPart) for p in self.parts)

    def has_text(self) -> bool:
        return any(isinstance(p, TextPart) for p in self.parts)

    def get_text_content(self) -> str:
        return "\n\n".join(p.get_content() for p in self.parts)

    T_co = TypeVar("T_co")

    def get_object_content(self, cls: Type[T_co]) -> T_co:
        return JsonSchema.deserialize(self.get_text_content(), cls)

    ##### --- tool‑calls ---------------------------------------------------- #
    def has_tool_calls(self) -> bool:
        from tool_call import ToolCall  # local import to avoid cyclic deps

        return any(isinstance(p, ToolCall) for p in self.parts)

    def get_tool_calls(self) -> list["ToolCall"]:
        from tool_call import ToolCall  # local import to avoid cyclic deps

        return [p for p in self.parts if isinstance(p, ToolCall)]

    def has_tool_call_results(self) -> bool:
        from tool_call_result import ToolCallResult  # local import

        return any(isinstance(p, ToolCallResult) for p in self.parts)

    def get_tool_call_results(self) -> list["ToolCallResult"]:
        from tool_call_result import ToolCallResult  # local import

        return [p for p in self.parts if isinstance(p, ToolCallResult)]

    ##### ------------------------------------------------------------------ #
    # Representation helpers
    ##### ------------------------------------------------------------------ #
    def __str__(self) -> str:  # pragma: no cover
        return f"{self.author}: {self.get_text_content()}"

    __repr__ = __str__


##### --------------------------------------------------------------------------- #
##### ChatCompletion – wraps a model’s reply
##### --------------------------------------------------------------------------- #
class ChatCompletion:
    """Encapsulates the reply produced by a language‑model."""

    ##### --------------------------- finish reasons ------------------------ #
    class FinishReason(str):
        IN_PROGRESS = "in_progress"
        COMPLETED = "completed"
        TRUNCATED = "truncated"
        INAPPROPRIATE = "inappropriate"
        OTHER = "other"

        def __new__(cls, value: str):
            return str.__new__(cls, value)

    ##### --------------------------- life‑cycle ---------------------------- #
    def __init__(
        self,
        finish_reason: "ChatCompletion.FinishReason",
        message: ChatMessage,
    ) -> None:
        if finish_reason is None:
            raise ValueError("finish_reason must not be None")
        if message is None:
            raise ValueError("message must not be None")

        self.finish_reason: ChatCompletion.FinishReason = finish_reason
        self.message: ChatMessage = message

    ##### ------------------------------------------------------------------ #
    # Convenience
    ##### ------------------------------------------------------------------ #
    def get_text(self) -> str:
        return self.message.get_text_content()

    T_co = TypeVar("T_co")

    def get_object(self, cls: Type[T_co]) -> T_co:
        """Parse the textual content as JSON into *cls*."""
        return self.message.get_object_content(cls)

## critic_module.py


from __future__ import annotations

import logging
from typing import List, Mapping

from agent import Agent
from json_schema import JsonSchema
from react_agent import ReactAgent
from steps import Step, ToolCallStep
from tool import Tool

##### --------------------------------------------------------------------------- #
##### Logging configuration (equivalent to Java SimpleLogger)
##### --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


class CriticModule(Agent):
    """
    Critic component of a `ReactAgent`.

    It reviews the executor’s actions and suggests improvements when necessary.
    """

    ##### --------------------------------------------------------------------- #
    # Prompt templates
    ##### --------------------------------------------------------------------- #
    _PROMPT_TEMPLATE: str = (
        "# Identity\n\n"
        "You are a reviewer agent; your task is to monitor how an executor agent "
        "tries to execute user's commands and provide suggestion to improve execution.\n"
        "The specific user's command the executor is trying to execute is provided "
        "in the below <user_command> tag.\n"
        "\n<user_command>\n{{command}}\n</user_command>\n\n"
        "You will be provided by the user with a potentially empty list of execution "
        "steps, in <steps> tag, that have been already performed by the executor in "
        "its attempt to execute the user's command. The format of these steps is "
        "provided as a JSON schema in <step_format> tag below. In these steps, the "
        'executor agent is identified with actor=="{{executor_id}}".\n'
        "\n<step_format>\n"
        + JsonSchema.get_json_schema(ToolCallStep) +
        "\n</step_format>\n\n"
        "\n# Additional Context and Information\n\n"
        "  * In order to execute the command, the executor agent has the tools "
        "described in the below <tools> tag at its disposal:\n\n"
        "<tools>\n{{tools}}\n</tools>\n\n"
        "{{context}}\n"
    )

    _REVIEW_TOOL_CALL_TEMPLATE: str = (
        _PROMPT_TEMPLATE
        + "\n# Instructions\n\n"
        "  * If the steps contain evidence that the executor entered a loop calling "
        "the same tool repeatedly with identical parameters, suggest strictly calling "
        "another tool for the next step.\n"
        "  * If and only if the last step contains a tool call that resulted in an "
        "error, inspect the tool definition and check for missing or unsupported "
        "parameters; attempt to retrieve missing parameter values from previous "
        'steps’ "observation" fields. Suggest repeating the call with the recovered '
        "values and flag unsupported parameters.\n"
        '  * **IMPORTANT** In every other case, or when no relevant advice applies, '
        'output exactly "CONTINUE". Do not add comments when outputting "CONTINUE", '
        "and do not output \"CONTINUE\" when you have a suggestion."
    )

    _REVIEW_CONCLUSIONS_TEMPLATE: str = (
        _PROMPT_TEMPLATE
        + "\n# Instructions\n\n"
        '  * If, and only if, the last step has status="ERROR", carefully inspect all '
        "steps to identify the root cause and provide a remediation suggestion.\n"
        '  * If, and only if, the last step has status="COMPLETED", verify through '
        '"observation" or "thought" fields that no further work is pending; if more '
        "actions are required, suggest those actions.\n"
        '  * **IMPORTANT** In every other scenario, or when no advice is relevant, '
        'output exactly "CONTINUE". Do not add comments when outputting "CONTINUE".\n'
        '  * Consider a tool invocation valid evidence only when an "action" field '
        "explicitly references a tool; ignore claims in \"thought\" or \"observation\" "
        "that are not backed by such evidence.\n"
        "{{examples}}\n"
    )

    ##### --------------------------------------------------------------------- #
    # Constructor
    ##### --------------------------------------------------------------------- #
    def __init__(
        self,
        agent: ReactAgent,
        tools: List[Tool],
        model: str,
    ) -> None:
        if agent is None:
            raise ValueError("agent must not be None")
        if tools is None:
            raise ValueError("tools must not be None")
        if model is None:
            raise ValueError("model must not be None")

        # The critic does not call any tool, therefore `tools=[]`
        super().__init__(
            id_=f"{agent.id}-critic",
            description=f"Critic module for {agent.id} agent",
            tools=[],
        )
        self._agent: ReactAgent = agent
        self._tools: List[Tool] = list(tools)

        self.temperature = 0.0
        self.model = model

    ##### ------------------------------------------------------------------ #
    # Read-only properties
    ##### ------------------------------------------------------------------ #
    @property
    def agent(self) -> ReactAgent:  # noqa: D401
        """Return the parent `ReactAgent`."""
        return self._agent

    ##### ------------------------------------------------------------------ #
    # Public API
    ##### ------------------------------------------------------------------ #
    def review_tool_call(self, steps: List[Step]) -> str:
        """Review the latest tool call performed by the executor."""
        return self._review(self._REVIEW_TOOL_CALL_TEMPLATE, steps)

    def review_conclusions(self, steps: List[Step]) -> str:
        """Review the executor’s final conclusions."""
        return self._review(self._REVIEW_CONCLUSIONS_TEMPLATE, steps)

    ##### ------------------------------------------------------------------ #
    # Internal logic
    ##### ------------------------------------------------------------------ #
    def _review(self, template: str, steps: List[Step]) -> str:
        if steps is None:
            raise ValueError("steps must not be None")

        # Prepare placeholders for the prompt
        mapping: Mapping[str, str] = {
            "command": self._agent.executor.command,
            "executor_id": self._agent.executor.id,
            "context": self._agent.context,
            "tools": self._build_tool_description(self._tools),
            "steps": JsonSchema.serialize(steps),
        }

        # Set critic personality
        self.personality = Agent.fill_slots(template, mapping)

        # As in Java: send the same message twice
        self.clear_conversation()
        prompt = Agent.fill_slots("<steps>\n{{steps}}\n</steps>", mapping)
        suggestion = self.chat(prompt).get_text()
        logger.debug("**** Suggestion: %s", suggestion)

        # Second call (mirrors original behaviour)
        return self.chat(prompt).get_text()

    ##### ------------------------------------------------------------------ #
    # Helpers
    ##### ------------------------------------------------------------------ #
    @staticmethod
    def _build_tool_description(tools: List[Tool]) -> str:
        """
        Build a human-readable description of the tools available to the executor.
        """
        sections: List[str] = []
        for tool in tools:
            sections.extend(
                [
                    "## Tool\n\n",
                    f"### Tool ID: {tool.id}\n",
                    "### Tool Description\n",
                    f"{tool.description}\n",
                    "### Tool Parameters (as JSON schema)\n",
                    f"{tool.json_parameters}\n\n",
                ]
            )
        return "".join(sections)

## execution_context.py

from __future__ import annotations

import logging
import sys
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import TYPE_CHECKING, Any, Dict, List, Mapping, MutableMapping, Sequence

##### --------------------------------------------------------------------------- #
##### Logging configuration (equivalent to Java SimpleLogger)
##### --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
    stream=sys.stderr,
)
logger = logging.getLogger(__name__)

##### --------------------------------------------------------------------------- #
#### Forward references to avoid circular-import issues
##### --------------------------------------------------------------------------- #
if TYPE_CHECKING:  # pragma: no cover
    from steps import Step
    from peace import Peace  # for Person, Task  (already ported)
    from peace import Person as _Person
    from peace import Task as _Task


##### --------------------------------------------------------------------------- #
##### ExecutionContext
##### --------------------------------------------------------------------------- #
class ExecutionContext:
    """
    Holds the *mutable* simulation state during a test run and offers
    utilities for logging and task filtering.
    """

    ##### ------------------------- life-cycle ------------------------------ #
    def __init__(
        self,
        db: "ExecutionContext.DbConnector",
        scenario_id: str,
        run_id: str,
    ) -> None:
        if db is None:
            raise ValueError("db must not be None")
        if scenario_id is None:
            raise ValueError("scenario_id must not be None")
        if run_id is None:
            raise ValueError("run_id must not be None")

        self.db: ExecutionContext.DbConnector = db
        self.scenario_id: str = scenario_id
        self.run_id: str = run_id

        # Dynamic state ------------------------------------------------- #
        self.unassigned_tasks: list["_Task"] | None = None
        self.operator_tasks: list["_Task"] = []
        self.related_persons: dict[str, "_Person"] | None = None

        self.proforma_document: dict[str, str] = {}
        self.sks: dict[str, str] = {}
        self.poa: dict[str, str] = {}

        self.log_entries: list[ExecutionContext.LogEntry] = []

    ##### ------------------------------------------------------------------ #
    # Database connector (abstract)                                      #
    ##### ------------------------------------------------------------------ #
    class DbConnector:
        """A pluggable persistence hook used by the simulator."""

        def add_step(self, run_id: str, step: "Step") -> None:  # noqa: D401
            raise NotImplementedError

    ##### ------------------------------------------------------------------ #
    # Log entries                                                        #
    ##### ------------------------------------------------------------------ #
    class LogEntryType(str, Enum):
        API_CALL = "API_CALL"
        PAYMENT = "PAYMENT"
        DIARY_ENTRY = "DIARY_ENTRY"
        INTERACTION = "INTERACTION"
        EMAIL = "EMAIL"
        UPLOAD = "UPLOAD"

        def __str__(self) -> str:  # pragma: no cover
            return str(self.value)

    @dataclass
    class LogEntry:
        """Base class for every log entry."""

        type: "ExecutionContext.LogEntryType"

        def __str__(self) -> str:  # pragma: no cover
            return f">>> {self.type} LOGGED"

    ##### ------------------------- concrete entries ----------------------- #
    @dataclass
    class ApiCallEntry(LogEntry):
        scenario_id: str
        tool_id: str
        args: dict[str, Any] = field(default_factory=dict)

        def __str__(self) -> str:
            args_formatted = " ".join(f'{k}="{v}"' for k, v in self.args.items())
            return (
                f">>> API CALL LOGGED > {self.scenario_id}: {self.tool_id}({args_formatted})"
            )

    @dataclass
    class DiaryEntry(LogEntry):
        task_time_created: str
        task_customer_number: str
        category: str
        message: str

        def __str__(self) -> str:
            return (
                f">>> DIARY ENTRY LOGGED > For task {self.task_customer_number} - "
                f"{self.task_time_created}\n    [{self.category}] {self.message}"
            )

    @dataclass
    class EmailEntry(LogEntry):
        recipient: str
        message: str

        def __str__(self) -> str:
            return (
                f">>> OUTGOING EMAIL LOGGED >  To: {self.recipient}\nContent: {self.message}"
            )

    @dataclass
    class InteractionEntry(LogEntry):
        message: str

        def __str__(self) -> str:
            return f">>> INTERACTION LOGGED > {self.message}"

    @dataclass
    class PaymentEntry(LogEntry):
        amount: str
        message: str

        def __str__(self) -> str:
            return f">>> PAYMENT LOGGED > Amount: {self.amount} -> {self.message}"

    @dataclass
    class UploadEntry(LogEntry):
        customer_number: str
        document_type: str
        content: str

        def __str__(self) -> str:
            return (
                f">>> {self.document_type} FILE UPLOADED > for client "
                f"{self.customer_number} CONTENT -> {self.content}"
            )

    ##### ------------------------------------------------------------------ #
    # Logging convenience wrappers                                       #
    ##### ------------------------------------------------------------------ #
    def log(self, entry: "ExecutionContext.LogEntry") -> None:
        if entry is None:
            raise ValueError("entry must not be None")
        self.log_entries.append(entry)
        logger.info("%s", entry)

    ##### --- overloaded helpers (mirror Java API) ------------------------- #
    def log_api_call(self, scenario_id: str, tool_id: str, args: Mapping[str, Any]) -> None:
        self.log(
            ExecutionContext.ApiCallEntry(
                ExecutionContext.LogEntryType.API_CALL,
                scenario_id,
                tool_id,
                dict(args),
            )
        )

    def log_diary(
        self,
        task_time_created: str,
        task_customer_number: str,
        category: str,
        message: str,
    ) -> None:
        self.log(
            ExecutionContext.DiaryEntry(
                ExecutionContext.LogEntryType.DIARY_ENTRY,
                task_time_created,
                task_customer_number,
                category,
                message,
            )
        )

    def log_interaction(self, message: str) -> None:
        self.log(
            ExecutionContext.InteractionEntry(
                ExecutionContext.LogEntryType.INTERACTION,
                message,
            )
        )

    def log_payment(self, amount: str, message: str) -> None:
        self.log(
            ExecutionContext.PaymentEntry(
                ExecutionContext.LogEntryType.PAYMENT,
                amount,
                message,
            )
        )

    def clear_log(self) -> None:
        self.log_entries.clear()

    ##### ------------------------------------------------------------------ #
    # Static helpers – task filtering                                    #
    ##### ------------------------------------------------------------------ #
    @staticmethod
    def filter_tasks(
        tasks: Sequence["_Task"],
        filter_by: str | None = None,
        filter_value: str | None = None,
        customer_number: str | None = None,
    ) -> list["_Task"]:
        """
        Return tasks matching *customer_number* **and optionally** the
        (*filter_by*, *filter_value*) criterion.

        The filter_by string must correspond to the **JSON alias** of a field
        in the Task model (e.g. ``"Step Name"`` rather than ``step_name``).
        """
        if tasks is None:
            raise ValueError("tasks must not be None")

        def _matches(task: "_Task") -> bool:
            # Filter by customer number first (if provided)
            if customer_number and task.customer_number != customer_number:
                return False

            if filter_by and filter_value is not None:
                # Pydantic exposes alias→field mapping via model_fields
                for fld in task.model_fields.values():  # type: ignore[attr-defined]
                    if fld.alias == filter_by:
                        value = getattr(task, fld.name)
                        return str(value) == filter_value
                # If alias not found, nothing matches
                return False

            return True

        return [t for t in tasks if _matches(t)]

## executor_module.py

from __future__ import annotations

import json
import logging
from typing import List, Mapping, Sequence, TYPE_CHECKING

from agent import Agent
from chat_types import ChatCompletion, ToolCall, ToolCallResult
from json_schema import JsonSchema
from steps import Step, ToolCallStep, Status
from tool import Tool

if TYPE_CHECKING:
    from react_agent import ReactAgent

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


class ExecutorModule(Agent):

    ##### ------------------------------------------------------------------ #
    # Constants
    ##### ------------------------------------------------------------------ #
    MAX_STEPS: int = 40  # hard stop to avoid infinite loops

    _PROMPT_TEMPLATE: str = (
        "# Identity\n\n"
        "You are a ReAct (Reasoning and Acting) agent; your task is to execute "
        "the below user command in <user_command> tag.\n"
        "\n<user_command>\n{{command}}\n</user_command>\n\n"
        "You will be provided by the user with a potentially empty list of execution "
        "steps, in <steps> tag, that you have already performed in an attempt to "
        "execute the user's command. The format of these steps is provided as a JSON "
        "schema in <step_format> tag below.\n"
        "\n<step_format>\n"
        + JsonSchema.get_json_schema(ToolCallStep)
        + "\n</step_format>\n\n"
        "Together with the list of steps, the user might provide a suggestion about "
        "how to execute the next step.\n"
        "\n# Additional Context and Information\n\n"
        " * You are identified with actor=={{id}} in execution steps."
        "{{context}}\n\n"
        "\n# Instructions\n\n"
        "  * Carefully plan the steps required to execute the user's command, think "
        "it step by step.\n"
        "  * If the user provided a suggestion about how to progress execution, then "
        "**STRICTLY** follow that suggestion when planning the next step. The "
        "suggestion applies only to the very next step.\n"
        "  * At each step use the most suitable tool at your disposal. **NEVER** "
        "output a step to *describe* a tool call – call the tool directly.\n"
        "  * Your tools have no access to <steps>; therefore pass every required "
        "parameter explicitly.\n"
        "  * When you are completely done, output a final step with status="
        "\"COMPLETED\". Do **NOT** output status=\"COMPLETED\" if work remains.\n"
        "  * If you encounter an unrecoverable error, output a final step with "
        "status=\"ERROR\" and provide a detailed explanation in the \"observation\" "
        "field. Otherwise use status=\"IN_PROGRESS\" sparingly.\n"
        "  * The final step **MUST** match the JSON schema in <output_schema>.\n"
        "\n<output_schema>\n"
        + JsonSchema.get_json_schema(Step)
        + "\n</output_schema>\n"
        "\n## Other Examples\n\n"
        "{{examples}}\n"
    )

    def __init__(
        self,
        agent: "ReactAgent",
        tools: Sequence[Tool],
        check_last_step: bool,
        model: str,
    ) -> None:
        super().__init__(
            id_=f"{agent.id}-executor",
            description=f"Executor module for {agent.id} agent",
            tools=list(tools),
        )

        self._agent: ReactAgent = agent
        self._check_last_step: bool = bool(check_last_step)
        self._command: str | None = None

        self.temperature = 0.0
        self.model = model
        self.set_response_format(Step)

    ##### ------------------------------------------------------------------ #
    # convenience wrappers (delegate to ReactAgent)
    ##### ------------------------------------------------------------------ #
    @property
    def command(self) -> str | None:
        return self._command

    def _add_step(self, step: Step) -> None:
        self._agent.add_step(step)

    def _last_step(self) -> Step | None:
        return self._agent.get_last_step()

    ##### ------------------------------------------------------------------ #
    # main execution loop
    ##### ------------------------------------------------------------------ #
    def execute(self, command: str) -> Step:
        if command is None:
            raise ValueError("command must not be None")

        self._command = command
        self._agent.steps.clear()

        ##### --- personality & first bookkeeping step -------------------- #
        slots: Mapping[str, str] = {
            "command": command,
            "id": self.id,
            "context": self._agent.context,
            "examples": self._agent.examples,
        }
        self.personality = Agent.fill_slots(self._PROMPT_TEMPLATE, slots)

        first_step = (
            Step.builder()
            .actor(self.id)
            .status(Status.IN_PROGRESS)
            .thought(
                Agent.fill_slots(
                    (
                        "I am starting execution of the below user's command in "
                        "<user_command>\n\n<user_command>\n{{command}}\n</user_command>"
                    ),
                    slots,
                )
            )
            .observation("Execution just started.")
            .build()
        )
        self._add_step(first_step)

        suggestion = (
            "No suggestions. Proceed as you see best, using the tools at your disposal."
        )
        instructions_tpl = "<steps>\n{{steps}}\n</steps>\n\nSuggestion: {{suggestion}}"

        ##### --------------------- loop ----------------------------------- #
        while (
            len(self._agent.steps) < self.MAX_STEPS
            and (
                self._last_step() is None
                or self._last_step().status is None
                or self._last_step().status == Status.IN_PROGRESS
            )
        ):
            self.clear_conversation()

            steps_json = json.dumps(
                [
                    s.model_dump(exclude={"action_steps"})
                    if isinstance(s, ToolCallStep)
                    else s.model_dump()
                    for s in self._agent.steps
                ],
                separators=(",", ":"),
            )

            prompt = Agent.fill_slots(
                instructions_tpl,
                {"steps": steps_json, "suggestion": suggestion},
            )

            try:
                reply = self.chat(prompt)
            except Exception as exc:
                error_step = (
                    ToolCallStep.builder()
                    .actor(self.id)
                    .status(Status.ERROR)
                    .thought("I had something in mind...")
                    .action("LLM was called but this resulted in an error.")
                    .action_input(prompt)
                    .action_steps([])
                    .observation(str(exc))
                    .build()
                )
                self._add_step(error_step)
                break

            if reply.finish_reason != ChatCompletion.FinishReason.COMPLETED:
                truncated_step = (
                    ToolCallStep.builder()
                    .actor(self.id)
                    .status(Status.ERROR)
                    .thought("I had something in mind...")
                    .action("LLM was called but this resulted in a truncated message.")
                    .action_input(prompt)
                    .action_steps([])
                    .observation(f"Response finish reason: {reply.finish_reason}")
                    .build()
                )
                self._add_step(truncated_step)
                break

            ##### ------------------- handle model output ------------------ #
            if reply.message.has_tool_calls():
                with_error = False
                for call in reply.message.get_tool_calls():
                    try:
                        result = call.execute()
                    except Exception as exc:
                        result = ToolCallResult.from_exception(call, exc)
                        with_error = True
                    else:
                        with_error |= (
                            isinstance(result.result, str)
                            and "error" in result.result.lower()
                        )

                    args_no_thought = dict(call.arguments)
                    thought = args_no_thought.pop("thought", "No thought passed explicitly.")
                    call_step = (
                        ToolCallStep.builder()
                        .actor(self.id)
                        .status(Status.IN_PROGRESS)
                        .thought(str(thought))
                        .action(f'The tool "{call.tool.id}" has been called')
                        .action_input(JsonSchema.serialize(args_no_thought))
                        .action_steps(
                            call.tool.agent.steps  # type: ignore[attr-defined]
                            if hasattr(call.tool, "agent")
                            else []
                        )
                        .observation(str(result.result))
                        .build()
                    )
                    self._add_step(call_step)

                    if len(self._agent.steps) > self.MAX_STEPS:
                        break

                suggestion = (
                    self._agent.reviewer.review_tool_call(self._agent.steps)
                    if with_error
                    else "CONTINUE"
                )
            else:
                try:
                    step_obj = reply.get_object(Step)
                    step_obj.actor = self.id
                    self._add_step(step_obj)
                except Exception as exc:
                    fallback = (
                        Step.builder()
                        .actor(self.id)
                        .status(Status.ERROR)
                        .thought(f"I stopped because I encountered this error: {exc}")
                        .observation(reply.get_text())
                        .build()
                    )
                    self._add_step(fallback)

                if self._last_step().status == Status.IN_PROGRESS:
                    suggestion = (
                        "**STRICTLY** proceed with next steps, by calling appropriate tools."
                    )
                elif self._check_last_step:
                    suggestion = self._agent.reviewer.review_conclusions(self._agent.steps)
                    if "continue" not in suggestion.lower():
                        self._last_step().status = Status.IN_PROGRESS

        ##### --------------------- overflow ------------------------------- #
        if len(self._agent.steps) >= self.MAX_STEPS:
            overflow_step = (
                Step.builder()
                .actor(self.id)
                .status(Status.ERROR)
                .thought(
                    f"Execution was stopped because it exceeded maximum number of steps "
                    f"({self.MAX_STEPS})."
                )
                .observation("I probably entered some kind of loop.")
                .build()
            )
            self._add_step(overflow_step)
            logger.error("Maximum steps exceeded; aborting execution.")

        return self._last_step()  # type: ignore[return-value]

## json_schema.py

from __future__ import annotations

import json
from typing import Type, TypeVar
from pydantic import BaseModel, TypeAdapter

T = TypeVar("T", bound=BaseModel)

class JsonSchema:
    """
    Python version of the Java JsonSchema utility class.
    Provides methods for:
    1. Getting a JSON schema from a Pydantic model.
    2. Serializing a Pydantic model instance to JSON.
    3. Deserializing a JSON string to a Pydantic model instance.
    """

    @staticmethod
    def get_json_schema(cls: type[BaseModel]) -> str:
        """
        Returns the JSON schema (draft-07) for the given Pydantic model class.

        Args:
            cls: The Pydantic model class.

        Returns:
            A string containing the JSON schema for the class.
        """
        return json.dumps(cls.model_json_schema(), separators=(",", ":"))

    @staticmethod
    def serialize(obj: BaseModel) -> str:
        """
        Serializes a Pydantic model instance to a JSON string, omitting fields whose value is None.

        Args:
            obj: The Pydantic model instance.

        Returns:
            The JSON string representation of the model.
        """
        return obj.model_dump_json(exclude_none=True)

    @staticmethod
    def deserialize(json_str: str, cls: Type[T]) -> T:
        """
        Deserializes a JSON string into an instance of the specified Pydantic model class,
        ignoring unknown fields.

        Args:
            json_str: The JSON string to deserialize.
            cls: The Pydantic model class.

        Returns:
            An instance of the specified model class.
        """
        adapter = TypeAdapter(cls)
        return adapter.validate_json(json_str, strict=False)

## react_agent.py

from __future__ import annotations

import logging
from typing import List, Sequence, TYPE_CHECKING

from pydantic import BaseModel, Field

from agent import Agent
from json_schema import JsonSchema
from steps import Step
from tool import Tool

if TYPE_CHECKING:  # avoid circular imports at runtime
    from executor_module import ExecutorModule
    from critic_module import CriticModule

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


class ReactAgent(Agent):
    DEFAULT_MODEL: str = "gpt-4.1"

    class Parameters(BaseModel):
        thought: str = Field(
            ...,
            description="Your reasoning about why this tool has been called.",
        )

    ##### ------------------------------------------------------------------ #
    # construction
    ##### ------------------------------------------------------------------ #
    def __init__(
        self,
        id_: str,
        description: str,
        tools: Sequence[Tool],
        check_last_step: bool = True,
    ) -> None:
        super().__init__(id_=id_, description=description, tools=[])

        self.model = self.DEFAULT_MODEL
        self.temperature = 0.0

        self._context: str = ""
        self._examples: str = ""

        # list of execution steps moved here
        self._steps: List[Step] = []

        # inner modules
        from executor_module import ExecutorModule  # local import
        from critic_module import CriticModule

        self._executor: ExecutorModule = ExecutorModule(
            agent=self,
            tools=list(tools),
            check_last_step=check_last_step,
            model=self.DEFAULT_MODEL,
        )
        self._reviewer: CriticModule = CriticModule(
            agent=self,
            tools=list(tools),
            model=self.DEFAULT_MODEL,
        )

    ##### ------------------------------------------------------------------ #
    # context & examples
    ##### ------------------------------------------------------------------ #
    @property
    def context(self) -> str:
        return self._context

    @context.setter
    def context(self, value: str) -> None:
        if value is None:
            raise ValueError("context must not be None")
        self._context = value

    @property
    def examples(self) -> str:
        return self._examples

    @examples.setter
    def examples(self, value: str) -> None:
        if value is None:
            raise ValueError("examples must not be None")
        self._examples = value

    ##### ------------------------------------------------------------------ #
    # steps management (now owned by ReactAgent)
    ##### ------------------------------------------------------------------ #
    @property
    def steps(self) -> List[Step]:
        return self._steps

    def get_last_step(self) -> Step | None:
        return self._steps[-1] if self._steps else None

    def add_step(self, step: Step) -> None:
        self._steps.append(step)
        try:
            logger.info(JsonSchema.serialize(step))
        except Exception:
            logger.exception("Unable to serialise step for logging")

    ##### ------------------------------------------------------------------ #
    # inner modules (read-only)
    ##### ------------------------------------------------------------------ #
    @property
    def executor(self):  ##### -> ExecutorModule
        return self._executor

    @property
    def reviewer(self):  ##### -> CriticModule
        return self._reviewer

    ##### ------------------------------------------------------------------ #
    # delegate
    ##### ------------------------------------------------------------------ #
    def execute(self, command: str) -> Step:
        if command is None:
            raise ValueError("command must not be None")
        logger.info("Executing command: %s", command)
        return self._executor.execute(command)


## scenario_component.py

"""
scenario_component.py

Python translation of `com.infosys.small.pnbc.ScenarioComponent`.

The class loads scenario definitions from a folder containing one or more
*.json* files.  Each file must contain a JSON array whose elements conform
to the schema defined by :class:`Scenario`.

The implementation mirrors the original Java semantics while embracing
Pythonic conventions and type hints.
"""

from __future__ import annotations

import json
import logging
import os
from pathlib import Path
from typing import Any, Dict, List, Mapping, Optional

from pydantic import BaseModel, Field, ValidationError

##### --------------------------------------------------------------------------- #
##### Logging configuration (equivalent to Java SimpleLogger)
##### --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


##### --------------------------------------------------------------------------- #
##### Pydantic models mirroring the nested Java static classes
##### --------------------------------------------------------------------------- #
class Output(BaseModel):
    type: str
    value: str


class ScenarioToolCall(BaseModel):
    tool_id: str = Field(alias="tool_id")
    input: Dict[str, Any]
    output: List[Output]

    model_config = {"populate_by_name": True}


class Scenario(BaseModel):
    id: str
    description: str
    success_criteria: str = Field(alias="success_criteria")
    tool_calls: List[ScenarioToolCall] = Field(alias="tool_calls")

    model_config = {"populate_by_name": True}


class ScenarioMetadata(BaseModel):
    id: str = Field(alias="id")
    description: str = Field(alias="description")

    model_config = {"populate_by_name": True}


##### --------------------------------------------------------------------------- #
##### Main component
##### --------------------------------------------------------------------------- #
class ScenarioComponent:
    """
    Access-point for scenario definitions loaded from disk.

    Parameters
    ----------
    folder : str | os.PathLike
        Directory containing one or more JSON files with scenario definitions.
    """

    ##### ------------------------- construction ---------------------------- #
    def __init__(self, folder: str | os.PathLike) -> None:
        if folder is None:
            raise ValueError("folder must not be None")

        self.scenario_folder: Path = Path(folder)
        if not self.scenario_folder.is_dir():
            raise IOError(f"Scenario folder {self.scenario_folder} does not exist.")

        self._scenarios: List[Scenario] = []
        self._load_scenarios()

    # Factory mirroring Java getInstance() ----------------------------- #
    @classmethod
    def get_instance(cls) -> "ScenarioComponent":
        default = Path(
            "D:/Users/mzatt/Projects/DELETEME PnBC/pnbc-services/src/main/resources/scenarios"
        )
        return cls(default)

    ##### --------------------------- API ---------------------------------- #
    def list_scenarios(self) -> List[Scenario]:
        """Return a *copy* of all scenarios loaded in memory."""
        return list(self._scenarios)

    def get_scenario(self, scenario_id: str) -> Optional[Scenario]:
        """
        Return the scenario with *scenario_id*, or *None* if not found.
        """
        if scenario_id is None:
            raise ValueError("scenario_id must not be None")

        for s in self._scenarios:
            if scenario_id == s.id:
                return s
        return None

    def get_success_criteria(self, scenario_id: str) -> Optional[str]:
        """Return the success criteria for *scenario_id*, if available."""
        scenario = self.get_scenario(scenario_id)
        return None if scenario is None else scenario.success_criteria

    def get(
        self,
        scenario_id: str,
        tool_id: str,
        args: Mapping[str, Any],
    ) -> str:
        """
        Retrieve the **text** output for the specified tool invocation.

        The logic follows the original Java implementation:
        * If the scenario does not exist → return an *ERROR* string.
        * Iterate through tool calls, match both *tool_id* and *args*.
        * Concatenate the value of every output whose type is ``"text"``.
        * If no matching call is found → generic *ERROR* string.
        """
        if scenario_id is None or tool_id is None or args is None:
            raise ValueError("scenario_id, tool_id and args must not be None")

        scenario = self.get_scenario(scenario_id)
        if scenario is None:
            return f"ERROR: Scenario {scenario_id} does not exist."

        for call in scenario.tool_calls:
            if call.tool_id != tool_id:
                continue
            if not self._matched(call.input, args):
                continue
            return "".join(o.value for o in call.output if o.type == "text")

        return "ERROR: System failure, wrong API call parameters."

    ##### --------------------- internal helpers --------------------------- #
    def _load_scenarios(self) -> None:
        """Populate :pyattr:`_scenarios` from JSON files in *scenario_folder*."""
        files = [p for p in self.scenario_folder.iterdir() if p.suffix == ".json"]
        if not files:
            raise IOError("Scenario folder is empty or contains no *.json* files.")

        for file in files:
            try:
                with file.open(encoding="utf-8") as fh:
                    data = json.load(fh)
                self._scenarios.extend(Scenario.model_validate(o) for o in data)
            except (json.JSONDecodeError, ValidationError) as exc:
                logger.error("Error parsing scenario %s", file.name, exc_info=exc)
                raise

    # Map-normalisation & matching logic (verbatim port) --------------- #
    @staticmethod
    def _transform_map(raw: Mapping[str, Any]) -> Dict[str, str]:
        result: Dict[str, str] = {}
        for k, v in raw.items():
            new_key = "" if k is None else str(k).lower().strip()
            new_val = "" if v is None else str(v).lower().strip()
            result[new_key] = new_val
        return result

    @classmethod
    def _matched(cls, map1: Mapping[str, Any], map2: Mapping[str, Any]) -> bool:
        t1 = cls._transform_map(map1)
        t2 = cls._transform_map(map2)
        for k, v in t1.items():
            if k not in t2 or t2[k] != v:
                return False
        return True

## steps.py

from __future__ import annotations

import logging
from enum import Enum
from typing import List, Self

from pydantic import BaseModel, Field, model_validator

##### --------------------------------------------------------------------------- #
##### Logging configuration (equivalent to Java SimpleLogger)
##### --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


class Status(str, Enum):
    """Execution status for a ReAct step."""

    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    ERROR = "ERROR"


class Step(BaseModel):
    """
    Python equivalent of `ReactAgent.Step`.

    Fields
    ------
    status       : optional execution status.
    actor        : identifier of the agent/tool performing the step.
    thought      : reasoning for this step.
    observation  : outcome, error details, or any additional data.
    """

    status: Status | None = Field(
        default=None,
        description=(
            "If you finish the execution or experience an unrecoverable error, "
            "set this to either COMPLETED or ERROR respectively."
        ),
    )
    actor: str = Field(..., description="The tool or agent that executed this step.")
    thought: str = Field(
        ...,
        description="Your reasoning about why and how you accomplish this step.",
    )
    observation: str = Field(
        ...,
        description="Any additional data, like step outcomes, error messages, etc.",
    )

    ##### ------------------------------------------------------------------ #
    # Fluent builder pattern
    ##### ------------------------------------------------------------------ #
    class Builder:
        def __init__(self) -> None:
            self._status: Status | None = None
            self._actor: str | None = None
            self._thought: str | None = None
            self._observation: str | None = None

        ##### --- fluent setters ------------------------------------------- #
        def status(self, status: Status) -> Self:  # noqa: D401
            self._status = status
            return self

        def actor(self, actor: str) -> Self:  # noqa: D401
            if actor is None:
                raise ValueError("actor must not be None")
            self._actor = actor
            return self

        def thought(self, thought: str) -> Self:  # noqa: D401
            if thought is None:
                raise ValueError("thought must not be None")
            self._thought = thought
            return self

        def observation(self, observation: str) -> Self:  # noqa: D401
            if observation is None:
                raise ValueError("observation must not be None")
            self._observation = observation
            return self

        ##### --- build ----------------------------------------------------- #
        def build(self) -> "Step":
            return Step(
                status=self._status,
                actor=self._actor or self._raise("actor"),
                thought=self._thought or self._raise("thought"),
                observation=self._observation or self._raise("observation"),
            )

        ##### --- helpers --------------------------------------------------- #
        @staticmethod
        def _raise(field_name: str) -> None:
            raise ValueError(f"{field_name} must not be None")

    # Provide static factory for parity with Java
    @staticmethod
    def builder() -> "Step.Builder":
        return Step.Builder()


class ToolCallStep(Step):
    """
    Python equivalent of `ReactAgent.ToolCallStep`, extending `Step`.
    """

    action: str = Field(
        ...,
        description="The action that was taken at this step. Typically a tool invocation.",
    )
    action_input: str = Field(
        ...,
        alias="action_input",
        description="Input for the action.",
    )
    action_steps: List[Step] = Field(
        default_factory=list,
        alias="action_steps",
        description=(
            "If the action was delegated to another agent, this is the list "
            "of steps that agent performed."
        ),
    )

    ##### ------------------------------------------------------------------ #
    # Fluent builder pattern
    ##### ------------------------------------------------------------------ #
    class Builder(Step.Builder):
        def __init__(self) -> None:
            super().__init__()
            self._action: str | None = None
            self._action_input: str | None = None
            self._action_steps: List[Step] = []

        ##### --- fluent setters ------------------------------------------- #
        def action(self, action: str) -> Self:  # noqa: D401
            if action is None:
                raise ValueError("action must not be None")
            self._action = action
            return self

        def action_input(self, action_input: str) -> Self:  # noqa: D401
            if action_input is None:
                raise ValueError("action_input must not be None")
            self._action_input = action_input
            return self

        def action_steps(self, steps: List[Step]) -> Self:  # noqa: D401
            self._action_steps = list(steps)
            return self

        def add_step(self, step: Step) -> Self:  # noqa: D401
            self._action_steps.append(step)
            return self

        ##### --- build ----------------------------------------------------- #
        def build(self) -> "ToolCallStep":
            return ToolCallStep(
                status=self._status,
                actor=self._actor or self._raise("actor"),
                thought=self._thought or self._raise("thought"),
                observation=self._observation or self._raise("observation"),
                action=self._action or self._raise("action"),
                action_input=self._action_input or self._raise("action_input"),
                action_steps=self._action_steps,
            )

    # Provide static factory for parity with Java
    @staticmethod
    def builder() -> "ToolCallStep.Builder":
        return ToolCallStep.Builder()

    ##### ------------------------------------------------------------------ #
    # Ensure alias names work both ways
    ##### ------------------------------------------------------------------ #
    model_config = {"populate_by_name": True}

    ##### ------------------------------------------------------------------ #
    # Validation to keep `status` optional but consistent
    ##### ------------------------------------------------------------------ #
    @model_validator(mode="after")
    def _check_required(cls, values):  # noqa: N805
        # actor, thought, observation, action, action_input are ensured by Pydantic
        return values

## tool.py

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from typing import Any, Mapping, Type

##### --------------------------------------------------------------------------- #
##### Logging configuration (equivalent to Java SimpleLogger)
##### --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

##### --------------------------------------------------------------------------- #
##### Forward references to avoid circular imports
##### --------------------------------------------------------------------------- #
if False:  # type-checking only
    from agent import Agent
    from tool_call import ToolCall
    from tool_call_result import ToolCallResult

from json_schema import JsonSchema  # noqa: E402  (local project import)


##### --------------------------------------------------------------------------- #
##### Tool ­– Python equivalent of the Java interface
##### --------------------------------------------------------------------------- #
class Tool(ABC):
    """
    Base protocol for every tool the agent can call.
    Sub-classes must implement :meth:`invoke`.
    """

    ##### --------------------------------------------------------------------- #
    # Public attributes expected by the agent
    ##### --------------------------------------------------------------------- #
    id: str
    description: str
    json_parameters: str

    ##### --------------------------------------------------------------------- #
    # Life-cycle hooks
    ##### --------------------------------------------------------------------- #
    @abstractmethod
    def is_initialized(self) -> bool: ...

    @abstractmethod
    def is_closed(self) -> bool: ...

    @abstractmethod
    def init(self, agent: "Agent") -> None: ...

    ##### --------------------------------------------------------------------- #
    # Core functionality
    ##### --------------------------------------------------------------------- #
    @abstractmethod
    def invoke(self, call: "ToolCall") -> "ToolCallResult": ...

    @abstractmethod
    def close(self) -> None: ...


##### --------------------------------------------------------------------------- #
##### AbstractTool ­– shared implementation for concrete tools
##### --------------------------------------------------------------------------- #
class AbstractTool(Tool):
    """
    Convenient super-class that handles common responsibilities:
    * life-cycle management (`init`, `close`)
    * JSON-schema generation for parameters
    * helper methods to parse arguments passed as strings

    Parameters
    ----------
    id_ : str
        Unique identifier for the tool (used by the agent and the model).
    description : str, optional
        Human-readable description of the tool’s purpose.
    parameters_cls : type
        A class (typically a *pydantic* model) describing the tool parameters.
        Its JSON schema is exposed through :pyattr:`json_parameters`.
    """

    ##### --------------------------------------------------------------------- #
    # Construction & life-cycle
    ##### --------------------------------------------------------------------- #
    def __init__(
        self,
        id_: str,
        description: str | None = None,
        parameters_cls: Type | None = None,
    ) -> None:
        if id_ is None:
            raise ValueError("id_ must not be None")
        if parameters_cls is None:
            raise ValueError("parameters_cls must not be None")

        self.id: str = id_
        self.description: str = description or ""
        self.json_parameters: str = JsonSchema.get_json_schema(parameters_cls)

        self._agent: "Agent | None" = None
        self._closed: bool = False

    ##### --------------------------------------------------------------------- #
    # Life-cycle helpers
    ##### --------------------------------------------------------------------- #
    def is_initialized(self) -> bool:
        return self._agent is not None

    def is_closed(self) -> bool:
        return self._closed

    def init(self, agent: "Agent") -> None:
        if agent is None:
            raise ValueError("agent must not be None")
        if self.is_initialized():
            raise RuntimeError(f"Tool {self.id} is already initialized")
        if self.is_closed():
            raise RuntimeError(f"Tool {self.id} is already closed")

        self._agent = agent
        logger.debug("Tool %s initialised", self.id)

    def close(self) -> None:
        self._closed = True
        logger.debug("Tool %s closed", self.id)

    ##### --------------------------------------------------------------------- #
    # Static helpers for argument parsing
    ##### --------------------------------------------------------------------- #
    @staticmethod
    def get_boolean(name: str, args: Mapping[str, Any], default: bool | None = None) -> bool:
        if name not in args:
            if default is not None:
                return default
            raise ValueError(f'Missing required parameter "{name}".')

        value = args[name]
        if isinstance(value, bool):
            return value
        if isinstance(value, str):
            s = value.strip().lower()
            if s == "true":
                return True
            if s == "false":
                return False

        raise ValueError(f'Parameter "{name}" is expected to be a boolean value but it is not.')

    @staticmethod
    def get_long(name: str, args: Mapping[str, Any], default: int | None = None) -> int:
        if name not in args:
            if default is not None:
                return default
            raise ValueError(f'Missing required parameter "{name}".')

        try:
            return int(args[name])
        except Exception as exc:  # noqa: BLE001
            raise ValueError(f'Parameter "{name}" is expected to be an integer value but it is not.') from exc

    @staticmethod
    def get_double(name: str, args: Mapping[str, Any], default: float | None = None) -> float:
        if name not in args:
            if default is not None:
                return default
            raise ValueError(f'Missing required parameter "{name}".')

        try:
            return float(args[name])
        except Exception as exc:  # noqa: BLE001
            raise ValueError(f'Parameter "{name}" is expected to be a decimal number but it is not.') from exc

    @staticmethod
    def get_string(name: str, args: Mapping[str, Any], default: str | None = None) -> str | None:
        if name not in args:
            return default
        value = args[name]
        return None if value is None else str(value)

## toolable_react_agent.py

from __future__ import annotations

import logging
from typing import Sequence

from pydantic import Field

from agent import Agent  # for type hints only
from react_agent import ReactAgent
from steps import Step, Status
from tool import AbstractTool, Tool, ToolCall, ToolCallResult

##### ---------------------------------------------------------------------------#
##### Logging configuration (Java-style simple logger)
##### ---------------------------------------------------------------------------#
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


##### ---------------------------------------------------------------------------#
##### ToolableReactAgent
##### ---------------------------------------------------------------------------#
class ToolableReactAgent(ReactAgent, AbstractTool):
    """
    A `ReactAgent` that can be used as a `Tool` by another agent.

    It inherits behaviour from both `ReactAgent` (conversation logic) and
    `AbstractTool` (tool life-cycle & helpers).
    """

    ##### --------------------------- parameters --------------------------- #
    class Parameters(ReactAgent.Parameters):
        """JSON-serialisable parameters for invoking the tool."""

        question: str = Field(
            ...,
            description=(
                "A question that this tool must answer or a command it must execute."
            ),
        )

    ##### ----------------------------- init ------------------------------- #
    def __init__(
        self,
        id_: str,
        description: str,
        tools: Sequence[Tool],
        check_last_step: bool = True,
    ) -> None:
        # Initialise the ReactAgent part (handles reasoning & tools)
        ReactAgent.__init__(
            self,
            id_=id_,
            description=description,
            tools=tools,
            check_last_step=check_last_step,
        )

        # Initialise the AbstractTool part (exposes tool metadata)
        AbstractTool.__init__(
            self,
            id_=id_,
            description=description,
            parameters_cls=ToolableReactAgent.Parameters,
        )

    ##### -##### -##### --------------------------- overrides ---------------------------- #
    def invoke(self, call: ToolCall) -> ToolCallResult:  # noqa: D401
        """
        Execute the wrapped ReAct agent to answer *question*.

        The `question` parameter is mandatory; errors are returned in
        `ToolCallResult` following the Java semantics.
        """
        if not self.is_initialized():
            raise RuntimeError("Tool must be initialized before invocation.")

        question = self.get_string("question", call.arguments)
        if question is None:
            return ToolCallResult.from_call(
                call,
                'ERROR: You must provide a command to execute as "question" parameter.',
            )

        # Delegate to the executor module of the underlying ReactAgent
        result_step: Step = self.execute(question)

        if result_step.status == Status.ERROR:
            return ToolCallResult.from_call(call, f"ERROR: {result_step.observation}")

        return ToolCallResult.from_call(call, result_step.observation)

    ##### ------------------------------------------------------------------ #
    # Clean-up
    ##### ------------------------------------------------------------------ #
    def close(self) -> None:
        """Close both the tool and the underlying agent."""
        AbstractTool.close(self)
        ReactAgent.close(self)
## lab_agent.py
"""
Python translation of `com.infosys.small.pnbc.LabAgent`.

The class extends `ToolableReactAgent` to provide simulation capabilities
through an `ExecutionContext` and can itself be used as a tool.
"""

from __future__ import annotations

import logging
from typing import Sequence

from chat_types import ToolCall, ToolCallResult
from execution_context import ExecutionContext
from steps import Status, Step
from tool import Tool
from toolable_react_agent import ToolableReactAgent

##### --------------------------------------------------------------------------- #
##### Logging (equivalent to Java SimpleLogger)
##### --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


##### --------------------------------------------------------------------------- #
##### LabAgent
##### --------------------------------------------------------------------------- #
class LabAgent(ToolableReactAgent):
    """
    An agent able to orchestrate simulated processes through an
    :class:`ExecutionContext`. The agent can also be invoked as a tool
    by other agents.
    """

    # ----------------------------- init ---------------------------------- #
    def __init__(
        self,
        id_: str,
        description: str,
        tools: Sequence[Tool],
        check_last_step: bool = False,
    ) -> None:
        super().__init__(
            id_=id_,
            description=description,
            tools=tools,
            check_last_step=check_last_step,
        )
        self.execution_context: ExecutionContext | None = None

    # ------------------------ helper accessors --------------------------- #
    def get_db(self) -> ExecutionContext.DbConnector:
        if self.execution_context is None:
            raise RuntimeError("Execution context is not set.")
        return self.execution_context.db

    def get_scenario_id(self) -> str:
        if self.execution_context is None:
            raise RuntimeError("Execution context is not set.")
        return self.execution_context.scenario_id

    def get_run_id(self) -> str:
        if self.execution_context is None:
            raise RuntimeError("Execution context is not set.")
        return self.execution_context.run_id

    def get_lab_agent(self) -> "LabAgent | None":  # noqa: D401
        """
        Return the outermost :class:`LabAgent` in the call chain (may be *self*),
        or *None* if not running under a LabAgent.
        """
        agent = self._agent
        if isinstance(agent, LabAgent):
            return agent
        from executor_module import ExecutorModule  # local import to break cycle

        if isinstance(agent, ExecutorModule):
            inner = agent.agent
            if isinstance(inner, LabAgent):  # pragma: no cover
                return inner
        return None

    # ------------------------- execution wrapper ------------------------- #
    def execute(self, ctx: ExecutionContext, command: str) -> Step:
        """
        Run a single command within the provided *ctx* simulation context.
        """
        if ctx is None:
            raise ValueError("ctx must not be None")
        if command is None:
            raise ValueError("command must not be None")

        self.execution_context = ctx
        return super().execute(command)

    # ------------------------------ invoke ------------------------------- #
    def invoke(self, call: ToolCall) -> ToolCallResult:  # noqa: D401
        """
        Allow other agents to use this `LabAgent` as a tool.
        """
        if call is None:
            raise ValueError("call must not be None")
        if not self.is_initialized():
            raise RuntimeError("Tool must be initialized before invocation.")

        question = self.get_string("question", call.arguments)
        if question is None:
            return ToolCallResult.from_call(
                call,
                'ERROR: You must provide a command to execute as "question" parameter.',
            )

        parent_lab = self.get_lab_agent()
        if parent_lab is None or parent_lab.execution_context is None:
            return ToolCallResult.from_call(call, "ERROR: Execution context is missing.")

        # Delegate execution within the caller’s context
        step = self.execute(parent_lab.execution_context, question)

        if step.status == Status.ERROR:
            return ToolCallResult.from_call(call, f"ERROR: {step.observation}")

        return ToolCallResult.from_call(call, step.observation)
        
## api.py
"""
Python translation of `com.infosys.small.pnbc.Api` – revised.

A single `invoke(...)` method now handles both normal and logged calls by means
of an optional `log` keyword-only flag.
"""

from __future__ import annotations

import logging
from typing import Any, Mapping, TYPE_CHECKING

from chat_types import ToolCall, ToolCallResult
from execution_context import ExecutionContext
from executor_module import ExecutorModule
from scenario_component import ScenarioComponent
from tool import AbstractTool

if TYPE_CHECKING:
    from lab_agent import LabAgent

##### --------------------------------------------------------------------------- #
##### Logging
##### --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


class Api(AbstractTool):
    """Abstract tool representing a simulated backend API."""

    # --------------------------- construction --------------------------- #
    def __init__(self, id_: str, description: str, schema: type) -> None:
        if id_ is None:
            raise ValueError("id_ must not be None")
        if schema is None:
            raise ValueError("schema must not be None")

        super().__init__(id_=id_, description=description, parameters_cls=schema)

    # ------------------------ helper accessors ------------------------- #
    def get_lab_agent(self) -> "LabAgent | None":
        agent = self._agent
        if isinstance(agent, LabAgent):  # type: ignore[name-defined]
            return agent
        if isinstance(agent, ExecutorModule):
            inner = agent.agent
            if isinstance(inner, LabAgent):  # type: ignore[name-defined]
                return inner
        return None

    def get_execution_context(self) -> ExecutionContext | None:
        lab = self.get_lab_agent()
        return lab.execution_context if lab else None

    def get_db(self) -> ExecutionContext.DbConnector:
        ctx = self.get_execution_context()
        if ctx is None:
            raise RuntimeError("Execution context is not set.")
        return ctx.db

    def get_scenario_id(self) -> str:
        ctx = self.get_execution_context()
        if ctx is None:
            raise RuntimeError("Execution context is not set.")
        return ctx.scenario_id

    def get_run_id(self) -> str:
        ctx = self.get_execution_context()
        if ctx is None:
            raise RuntimeError("Execution context is not set.")
        return ctx.run_id

    # ------------------------------ invoke ----------------------------- #
    def invoke(self, call: ToolCall, *, log: bool = False) -> ToolCallResult:  # noqa: D401
        """
        Execute the API.  
        Set `log=True` to record the call in the current ExecutionContext.
        """
        if call is None:
            raise ValueError("call must not be None")
        if not self.is_initialized():
            raise RuntimeError("Tool must be initialized before invocation.")

        # Clone & sanitise arguments
        args: dict[str, Any] = dict(call.arguments)
        args.pop("thought", None)  # remove LLM’s thought if present

        lab_agent = self.get_lab_agent()
        if lab_agent is None:
            raise RuntimeError("Unable to locate LabAgent in call hierarchy.")

        scenario_id = lab_agent.get_scenario_id()

        if log:
            lab_agent.execution_context.log_api_call(  # type: ignore[arg-type]
                scenario_id,
                self.id,
                args,
            )

        # Retrieve canned result
        result = ScenarioComponent.get_instance().get(scenario_id, self.id, args)
        return ToolCallResult.from_call(call, result)

</python>