You are an agent assisting a developer in translating some Java code into Python.
The Java code is provided below, in <java> tag.

Your task is to produce a single Python file with the translation of these classes: ChatCompletion, ChatMessage, FinishReason, MessagePart, TextPart, ToolCall, ToolCallResult by **STRICTLY** following the instructions below.

## Instructions

Read the code in <java> carefully before translating it into Python.
Java comments might contain directions about how to translate code in Python;  **STRICTLY** follow them if they are provided.
Some of the Java classes have already been translated into Python and they are provided in the <python> tag. If you need access to these class, provide the proper import directives in your Python code and assume the classes will be available; **STRICTLY** never use minimal fallback code.Be aware that the Java code uses Lombok annotations; you need to translate code generated by Lombok as well.
When translating Java fields and methods into Python, use proper naming convention (e.g. translate field names from camelCase into snake_case).
Always use type annotations (Python 3.6+).
When @NonNull is used in a method parameter, add code in the Python function that checks provided parameter value is not null.
Ignore the "final" attribute when converting from Java.
Translate RuntimeException as RuntimeError and IllegalArgumentException as ValueError.
Strictly always create comments in English; **NEVER** use Italian in your output.

### Logging

Java code uses Java libraries for logging (e.g. slf4j); when translating code to Python translate this by using equivalent methods in the logging standard library. For example:

```java
public class Agent {

	private final static Logger LOG = LoggerFactory.getLogger(Agent.class);

	...LOG.debug("Message");
```

Must be translated into somethign like:

```python
import logging

# configurationequivalent to Java SimpleLogger
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)

logger = logging.getLogger(__name__)  # as LoggerFactory.getLogger()

...


logger.debug("Message")

```



### Constructors

When translating Java overloaded constructors (which Python does not support), use one flexible __init__ plus a couple of convenience class-methods. This keeps the call-sites as short as in Java while complying with Python best-practice (PEP 8 naming, type hints, single source of truth).

For example, the below list of constructors for same class:

```java
public ChatMessage(String content) {
	this(Author.USER, content);
}

public ChatMessage(@NonNull MessagePart part) {
	this(Author.USER, part);
}

public ChatMessage(@NonNull List<? extends MessagePart> parts) {
	this(Author.USER, parts);
}

public ChatMessage(@NonNull Author author, String content) {
	this.author = author;
	if (content != null)
		parts.add(new TextPart(content));
}

public ChatMessage(@NonNull Author author, @NonNull MessagePart part) {
	this.author = author;
	this.parts.add(part);
}

public ChatMessage(@NonNull Author author, @NonNull List<? extends MessagePart> parts) {
	this.author = author;
	this.parts.addAll(parts);
}
```

Must be translated as:

```python
from __future__ import annotations
from collections.abc import Sequence
from typing import overload

class Author(str):
    USER = "user"
    SYSTEM = "system"
    # …

class MessagePart: ...
class TextPart(MessagePart):
    def __init__(self, content: str) -> None:
        self.content = content


class ChatMessage:
    """
    A port of the Java `ChatMessage` with the same semantics.

    Parameters
    ----------
    author : Author, default Author.USER
    parts  : • str                → wrapped in TextPart
             • MessagePart        → stored as-is
             • Sequence[MessagePart] → copied 1-to-1
    """
    # static type-checkers can still benefit from @overload
    @overload
    def __init__(self, content: str, author: Author = Author.USER) -> None: ...
    @overload
    def __init__(self, part: MessagePart, author: Author = Author.USER) -> None: ...
    @overload
    def __init__(
        self,
        parts: Sequence[MessagePart],
        author: Author = Author.USER,
    ) -> None: ...

    def __init__(
        self,
        first: str | MessagePart | Sequence[MessagePart],
        author: Author = Author.USER,
    ) -> None:
        self.author: Author = author
        self.parts: list[MessagePart] = []

        # --- normalise input -------------------------------------------------
        if isinstance(first, str):
            self.parts.append(TextPart(first))
        elif isinstance(first, MessagePart):
            self.parts.append(first)
        else:  # sequence of parts
            self.parts.extend(first)
        # ---------------------------------------------------------------------

    # ---------- alternate constructors (optional) ---------------------------
    @classmethod
    def from_content(cls, content: str, author: Author = Author.USER) -> "ChatMessage":
        return cls(content, author)

    @classmethod
    def from_part(cls, part: MessagePart, author: Author = Author.USER) -> "ChatMessage":
        return cls(part, author)
```

### Builder

The provided Java classes often use the Builder pattern either providing a Builder explicitly or using @Builder Lombok annotation.
In all of these cases, strictly use a “fluent interface” style pattern.

For example, this Java class:

```java
import lombok.Builder;
import lombok.Singular;
import lombok.Value;
import java.util.List;

@Builder             
public class PizzaOrder {

    @Builder.Default
    String size = "M";          

    @Singular
    List<String> toppings;      

    @Builder.Default
    boolean glutenFree = false; 
}
```

Must be translated in Python as follows:


```python
from dataclasses import dataclass, field
from typing import Self

@dataclass
class PizzaOrder:
    size: str = "M"
    toppings: list[str] = field(default_factory=list)
    gluten_free: bool = False

    # “fluent interface” style
    def with_size(self, size: str) -> Self:
        self.size = size
        return self

    def add_topping(self, name: str) -> Self:
        self.toppings.append(name)
        return self
```

### Getters and setters

Do not  translate literally java getters and setters in Python, rather follow the below logic:

  1. If no getter or setter is provided, make the field private using "_underscore naming"
  2. If any getter or setter is provided with Lombok annotations that is not private, then treat corresponding field as public in Python and give it direct attribute access. Do this regardless the access level for the getter/setter (e.g. if the getter is public and the setter is protected, treat the field as public).
  3. If any getter or setter is provided in Java with some logic, then use @property annotation in Python and translate corresponding Java logic.
  
When @NonNull is used in a class field, create a @property setter in Python that checks provided value is not null (None).
  

### Interfaces and Abstract classes

The Java code often uses an interface+abstract class pattern: typically there is an interface I and an abstract class AI that implements I, with the purpose to have developers extend AI for actual implementations of I; this also to allow Java classes to extend multiple interfaces whilst providing some boiler plate code in abstract classes.

An example of this pattern are the Tool and AbstractTool:

```java
public interface Tool {
	String getId();
	String getDescription();
	boolean isClosed();	
	void init(Agent agent);
	...other interface methods
}

public abstract class AbstractTool implements Tool {

	@Getter
	private final String id;

	@Getter
	private String description = "";

	@Getter
	@Setter(AccessLevel.PROTECTED)
	private boolean closed = false;
	
	@Override
	public void init(@NonNull Agent agent) {
		...implements init()
	}
}

public class MyTool extends AbstractTool implements Closeable {
	...
}
```

In Python this must be translated with a similar pattern, as shown below. Notice that the Tool interface defines getters as interface methods, but we have a 6rule to translate those into publicly accessible fields in Python

```python
from abc import ABC, abstractmethod
from typing import Protocol


class Tool(ABC):
    """Python equivalent of a Java interface, note getters are replaced with publicly accessible fields."""
    id: str
    description: str

    @abstractmethod
    def init(self, agent: "Agent") -> None: ...
    # ...other interface methods.


class AbstractTool(Tool):
    """Python equivalent of the Java abstract class"""
    def __init__(self, id_: str, description: str) -> None:
        self.id: str = id_
        self.description: str = description
        self.closed: bool = False

    def init(self, agent: "Agent") -> None:
        # ...implements init()


class MyTool(AbstractTool, Closeable):

    def close(self) -> None:
        # ...from Closeable
```

### JSON schema and serialisation

The Java class `JsonShema` is only meant to provide static methods to:

  1. Obtain a JSON schema from a class.
  2. Serialise an instance of a class into JSON.
  3. De-serialise the JSON representation of a class.
  
For 1. the class relies on Jackson annotations; an example is provided below.

Given this class annotated with Jackson annotations:

```java
@JsonSchemaDescription("This is a class describing parameters for GetCurrentWeatherTool")
public static class Parameters {

	private enum TemperatureUnits {
		CELSIUS, FARENHEIT
	};

	@JsonProperty(required = true)
	@JsonPropertyDescription("The city and state, e.g. San Francisco, CA.")
	public String location;

	@JsonPropertyDescription("Temperature unit (CELSIUS or FARENHEIT), defaults to CELSIUS")
	public TemperatureUnits unit;
}
```

Calling `JsonSchema.getJsonSchema(Parameters.class)` will return the following:

```
{"$schema":"http://json-schema.org/draft-04/schema#","title":"Parameters","type":"object","additionalProperties":false,"description":"This is a class describing parameters for GetCurrentWeatherTool","properties":{"location":{"type":"string","description":"The city and state, e.g. San Francisco, CA."},"unit":{"type":"string","enum":["CELSIUS","FARENHEIT"],"description":"Temperature unit (CELSIUS or FARENHEIT), defaults to CELSIUS"}},"required":["location"]}
```

When translating JsonSchema into Python, it is expected that pydantic and its annotations are used to generate an exact JSON schema like the above.

When translating Java classes into Python strictly ensure Jackson annotations are replaced with corresponding Pydantic ones.

<java>

## AbstractTool.java

package core;

import java.util.Map;

import com.fasterxml.jackson.core.JsonProcessingException;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

/**
 * This is an abstract class that implementations of {@link Tool}s can extend.
 * It mostly provides methods to read and cast arguments parameters into the right type.
 * 
 * @author Massimiliano "Maxi" Zattera
 */
public abstract class AbstractTool implements Tool {

	@Getter
	private final String id;

	@Getter
	private String description = "";

	/**
	 * JSON schema describing parameters for this tool.
	 */
	@Getter
	private final String jsonParameters;

	@Getter
	private Agent agent;

	@Getter
	@Setter(AccessLevel.PROTECTED)
	private boolean closed = false;

	@Override
	public boolean isInitialized() {
		return (agent != null);
	}

	@Override
	public void init(@NonNull Agent agent) {
		if (isInitialized())
			throw new RuntimeException("Tool " + id + " is already initialized");
		if (closed)
			throw new RuntimeException("Tool " + id + " is already closed");
		this.agent = agent;
	}

	protected AbstractTool(@NonNull String id, String description, @NonNull Class<?> c) throws JsonProcessingException {
		this.id = id;
		this.description = description;
		this.jsonParameters = JsonSchema.getJsonSchema(c);
	}

	@Override
	public void close() {
		closed = true;
	}

	//
	// Below there are utility methods to read parameters.
	// When translating these into Python you need to check whether parameters are of desired type OR
	// they are string values that can be parsed into instances of given type.
	//
	// ////////////////////////////////////////////////////////////////////////////////////////////

	protected static boolean getBoolean(String name, Map<String, ? extends Object> args) {
		if (args.containsKey(name))
			return getBoolean(name, args.get(name));
		throw new IllegalArgumentException("Missing required parameter \"" + name + "\".");
	}

	protected static boolean getBoolean(String name, Map<String, ? extends Object> args, boolean def) {
		if (!args.containsKey(name))
			return def;
		return getBoolean(name, args.get(name));
	}

	private static boolean getBoolean(String name, Object value) {
		String s = value.toString();
		if ("true".equals(s.trim().toLowerCase()))
			return true;
		if ("false".equals(s.trim().toLowerCase()))
			return false;

		throw new IllegalArgumentException(
				"Parameter \"" + name + "\" is expected to be a boolean value but it is not.");
	}

	protected static long getLong(String name, Map<String, ? extends Object> args) {
		if (args.containsKey(name))
			return getLong(name, args.get(name));
		throw new IllegalArgumentException("Missing required parameter \"" + name + "\".");
	}

	protected static long getLong(String name, Map<String, ? extends Object> args, long def) {
		if (!args.containsKey(name))
			return def;
		return getLong(name, args.get(name));
	}

	private static long getLong(String name, Object value) {
		try {
			return Long.parseLong(value.toString());
		} catch (Exception e) {
			throw new IllegalArgumentException(
					"Parameter \"" + name + "\" is expected to be a integer value but it is not.");
		}
	}

	protected static double getDouble(String name, Map<String, ? extends Object> args) {
		if (args.containsKey(name))
			return getDouble(name, args.get(name));
		throw new IllegalArgumentException("Missing required parameter \"" + name + "\".");
	}

	protected static double getDouble(String name, Map<String, ? extends Object> args, double def) {
		if (!args.containsKey(name))
			return def;
		return getDouble(name, args.get(name));
	}

	protected static double getDouble(String name, Object value) {
		try {
			return Double.parseDouble(value.toString());
		} catch (Exception e) {
			throw new IllegalArgumentException(
					"Parameter \"" + name + "\" is expected to be a decimal number but it is not.");
		}
	}

	protected static String getString(String name, Map<String, ? extends Object> args) {
		Object result = args.get(name);
		if (result == null)
			return null;
		return result.toString();
	}

	protected static String getString(String name, Map<String, ? extends Object> args, String def) {
		if (!args.containsKey(name))
			return def;
		return getString(name, args);
	}
}

### Agent.java

package core;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.openai.client.OpenAIClient;
import com.openai.client.okhttp.OpenAIOkHttpClient;
import com.openai.core.JsonMissing;
import com.openai.models.FunctionDefinition;
import com.openai.models.FunctionParameters;
import com.openai.models.ResponseFormatJsonSchema;
import com.openai.models.ResponseFormatJsonSchema.JsonSchema.Schema;
import com.openai.models.chat.completions.ChatCompletionAssistantMessageParam;
import com.openai.models.chat.completions.ChatCompletionAssistantMessageParam.Builder;
import com.openai.models.chat.completions.ChatCompletionCreateParams;
import com.openai.models.chat.completions.ChatCompletionCreateParams.ResponseFormat;
import com.openai.models.chat.completions.ChatCompletionDeveloperMessageParam;
import com.openai.models.chat.completions.ChatCompletionMessage;
import com.openai.models.chat.completions.ChatCompletionMessageParam;
import com.openai.models.chat.completions.ChatCompletionMessageToolCall;
import com.openai.models.chat.completions.ChatCompletionMessageToolCall.Function;
import com.openai.models.chat.completions.ChatCompletionTool;
import com.openai.models.chat.completions.ChatCompletionToolMessageParam;
import com.openai.models.chat.completions.ChatCompletionUserMessageParam;

import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

/**
 * This class implements an Agent that uses OpenAI models via the Chat
 * Completions API. This class is implemented using the OpenAI Java SDK.
 * 
 * @author Massimiliano "Maxi" Zattera
 */
public class Agent {

	private final static Logger LOG = LoggerFactory.getLogger(Agent.class);

	public static final String DEFAULT_MODEL = "gpt-4.1";

	protected Agent() {
		this("OpenAIChatCompletionService", "Test agent", new ArrayList<>());
	}

	protected Agent(@NonNull String id, @NonNull String description, @NonNull List<? extends Tool> tools) {
		this.client = OpenAIOkHttpClient.fromEnv();
		this.id = id;
		this.description = description;
		for (Tool t : tools) {
			t.init(this);
			toolMap.put(t.getId(), t);
		}
		this.model = DEFAULT_MODEL;
		this.temperature = 0.0d;
	}

	/**
	 * This class uses an OpenAIClient to call the OpenAI API. In python you do not
	 * need a client; you can omit this field and use openai intead.
	 * 
	 * E.g. instead of:
	 * 
	 * client.chat().completions().create(req);
	 * 
	 * In Python use:
	 * 
	 * import openai
	 * 
	 * openai.ChatCompletion.create(**req)
	 */
	protected final OpenAIClient client;

	/**
	 * Unique agent ID.
	 */
	@Getter
	private final String id;

	/**
	 * A verbose description of the agent, describing its capabilities.
	 */
	@Getter
	@Setter
	private String description;

	/**
	 * The name of the LLM model used by this agent (e.g. "gpt-4").
	 */
	@Getter
	@Setter
	private String model;

	/**
	 * Personality (system prompt) for the agent.
	 */
	@Getter
	@Setter
	private String personality;

	/**
	 * Messages exchanged so far in current conversation with the agent.
	 */
	@Getter
	private final List<ChatMessage> history = new ArrayList<>();

	/**
	 * The temperature of the sampling operation for the underlying LLM.
	 */
	@Getter
	@Setter
	private Double temperature = 0d;

	/**
	 * Starts a new chat, clearing current conversation.
	 */
	public void clearConversation() {
		history.clear();
	}

	/**
	 * Maximum number of messages to keep in chat history.
	 */
	@Getter
	@Setter
	private int maxHistoryLength = Integer.MAX_VALUE;

	/**
	 * Maximum number of history messages to send to LLM during a conversation.
	 * 
	 * Notice this does NOT limit length of conversation history (see
	 * {@link #getMaxHistoryLength}).
	 */
	@Getter
	@Setter
	private int maxConversationSteps = Integer.MAX_VALUE;

	/**
	 * Output format for the model, as JSON schema.
	 */
	@Getter
	private String responseFormat;

	/**
	 * This method allows to specify an output format for the model. This is used to
	 * create structured outputs with model supporting it so that, for example, the
	 * model returns its responses in a pre-defined JSON format.
	 * 
	 * @param schema A class which schema will be used to define the output format.
	 */
	public void setResponseFormat(Class<?> schema) {
		responseFormat = JsonSchema.getJsonSchema(schema);
	}

	/**
	 * Available and already initialized tools that agent can use. Maps each tool ID
	 * into corresponding tool instance.
	 */
	protected Map<String, Tool> toolMap = new HashMap<>();

	/**
	 * Continues current chat, with the provided message.
	 * 
	 * The exchange is added to the conversation history.
	 */
	public ChatCompletion chat(String msg) {
		return chat(new ChatMessage(ChatMessage.Author.USER, msg));

	}

	/**
	 * Continues current chat, with the provided message.
	 * 
	 * The exchange is added to the conversation history.
	 */
	public ChatCompletion chat(ChatMessage msg) {
		return chat(List.of(msg));
	}

	/**
	 * Continues current chat, with the provided messages.
	 * 
	 * The exchange is added to the conversation history.
	 */
	public ChatCompletion chat(List<ChatMessage> msg) {

		// Add messages to conversation and trims it; this also adds personality
		List<ChatMessage> conversation = new ArrayList<>(getHistory());
		conversation.addAll(msg);
		trimConversation(conversation);

		// Create response
		ChatCompletion result = chatCompletion(conversation);

		// Add messages and response to history
		getHistory().addAll(msg);
		getHistory().add(result.getMessage());

		// Make sure history is of desired length
		if (getHistory().size() > getMaxHistoryLength()) {
			getHistory().subList(0, getHistory().size() - getMaxHistoryLength()).clear();
		}

		return result;
	}

	/**
	 * Completes text outside a conversation (executes given prompt ignoring and
	 * without affecting conversation history).
	 * 
	 * Notice this does not consider or affects chat history but bot personality is
	 * used, if provided.
	 */
	public ChatCompletion complete(String prompt) {
		return complete(new ChatMessage(ChatMessage.Author.USER, prompt));
	}

	/**
	 * Completes text outside a conversation (executes given prompt ignoring and
	 * without affecting conversation history).
	 * 
	 * Notice this does not consider or affects chat history but bot personality is
	 * used, if provided.
	 */
	public ChatCompletion complete(ChatMessage prompt) {

		List<ChatMessage> conversation = List.of(prompt);
		trimConversation(conversation);

		return chatCompletion(conversation);
	}

	/**
	 * Trims given list of messages (typically a conversation history), so it fits
	 * the limits set in this instance (that is, maximum conversation steps).
	 * 
	 * Notice the personality (system prompt) is always and automatically added on
	 * top of the trimmed list (if set).
	 * 
	 * @throws IllegalArgumentException if no message can be added because of
	 *                                  context size limitations.
	 */
	private void trimConversation(List<ChatMessage> messages) {

		// Remove tool call results left on top without corresponding calls, or this
		// will cause HTTP 400 error for tools
		int firstNonToolIndex = 0;
		for (ChatMessage m : messages) {
			if (m.hasToolCallResults()) {
				firstNonToolIndex++;
			} else {
				break;
			}
		}
		if (firstNonToolIndex > 0) {
			messages.subList(0, firstNonToolIndex).clear();
		}

		// Trims down the list of messages accordingly to given limits.
		if (messages.size() > getMaxConversationSteps())
			messages.subList(0, messages.size() - getMaxConversationSteps()).clear();

		if (messages.size() == 0)
			throw new IllegalArgumentException("No messages left in conversation");

		if (getPersonality() != null)
			// must add a system message on top with personality
			messages.add(0, new ChatMessage(ChatMessage.Author.DEVELOPER, getPersonality()));
	}

	/**
	 * This method sends given list of messages to the LLM and creates corresponding
	 * chat response, which is returned.
	 */
	@SuppressWarnings("unchecked")
	private ChatCompletion chatCompletion(List<ChatMessage> messages) {

		// The method starts by building required ChatCompletionCreateParams instance to
		// call the OpenAI chat API.
		// When translating this into Python you should be a request req that is then
		// sent to openai.ChatCompletion.create(**req)

		// Translate messages into format suitable to be used with OpenAI API
		// Here each ChatMessage is translated into the corresponding
		// ChatCompletionMessageParam.
		List<ChatCompletionMessageParam> openAiMessages = new ArrayList<>();
		for (ChatMessage m : messages)
			openAiMessages.addAll(fromChatMessage(m));

		// ThHere we use a Builder to build ChatCompletionCreateParams step by step
		// Notice that here we set the model, the messages and the temperature
		// With OpenAI Java SDK, messages must be a list of ChatCompletionMessageParam
		// but in Python you might build them differently as part of req; check what
		// fromChatMessage() does
		ChatCompletionCreateParams.Builder b = ChatCompletionCreateParams.builder() //
				.model(getModel()) //
				.messages(openAiMessages) //
				.temperature(getTemperature());

		// Only if response format was set, provide it; check what
		// createResponseFormat() does
		if (getResponseFormat() == null)
			b.responseFormat(JsonMissing.of());
		else
			b.responseFormat(createResponseFormat());

		// If there is any tool, provide them in req; check what createToolDefinitions()
		// does
		if (toolMap.size() == 0)
			b.tools(JsonMissing.of());
		else
			b.tools(createToolDefinitions());
		ChatCompletionCreateParams req = b.build();

		LOG.info(req.toString());

		// Calls OpenAI Chat Completion API and returns result
		com.openai.models.chat.completions.ChatCompletion resp = client.chat().completions().create(req);
		com.openai.models.chat.completions.ChatCompletion.Choice choice = resp.choices().get(0);
		return new ChatCompletion(fromOpenAiApi(choice.finishReason()), fromOpenAiMessage(choice.message()));
	}

	/**
	 * Translates Java OpenAI SDK finish reason into one we can use.
	 */
	private static ChatCompletion.FinishReason fromOpenAiApi(
			com.openai.models.chat.completions.ChatCompletion.Choice.FinishReason finishReason) {
		switch (finishReason.value()) {
		case STOP:
		case TOOL_CALLS:
		case FUNCTION_CALL:
			return ChatCompletion.FinishReason.COMPLETED;
		case LENGTH:
			return ChatCompletion.FinishReason.TRUNCATED;
		case CONTENT_FILTER:
			return ChatCompletion.FinishReason.INAPPROPRIATE;
		default:
			throw new IllegalArgumentException("Unrecognized finish reason: " + finishReason);
		}
	}

	/**
	 * Turns an ChatCompletionMessageParam returned by API into a ChatMessage. This
	 * is required because we want to return ChatMessage objects and store them as
	 * such in the history.
	 */
	private ChatMessage fromOpenAiMessage(ChatCompletionMessage msg) {

		if (msg.toolCalls().isPresent()) {

			// The model returned a set of tool calls, transparently translate that into a
			// message with a multiple parts each being a ToolCall
			List<ToolCall> calls = new ArrayList<>();
			for (ChatCompletionMessageToolCall call : msg.toolCalls().get()) {
				ToolCall toolCall;
				try {
					toolCall = ToolCall.builder() //
							.id(call.id()) //
							.tool(toolMap.get(call.function().name())) //
							.arguments(call.function().arguments()) //
							.build();
				} catch (JsonProcessingException e) {
					throw new IllegalArgumentException(e);
				}
				calls.add(toolCall);
			}

			// Nothing else to return in this case
			return new ChatMessage(ChatMessage.Author.BOT, calls);
		}

		List<MessagePart> parts = new ArrayList<>();
		if (msg.content().isPresent()) {
			// Normal (text) message was returned, just add it as TextPart
			parts.add(new TextPart(msg.content().get()));
		}
		if (msg.refusal().isPresent()) {
			// OpenAI returned a refusal; translate it into a text message and attach it as
			// TextPart
			parts.add(new TextPart("**The model generated a refusal**\n\n" + msg.refusal().get()));
		}

		// Return a message with all the parts we found
		return new ChatMessage(ChatMessage.Author.BOT, parts);
	}

	/**
	 * This converts a generic ChatMessaege provided by user into an
	 * ChatCompletionMessageParam that is used for the OpenAi API. This is needed
	 * because we want to deal with ChatMessage when talking to the agent.
	 */
	private List<ChatCompletionMessageParam> fromChatMessage(ChatMessage msg) {

		if (msg.hasToolCalls()) {

			// The message contains tool calls; we translate them into a
			// ChatCompletionAssistantMessageParam which will contain all these calls
			Builder b = ChatCompletionAssistantMessageParam.builder();
			for (ToolCall c : msg.getToolCalls()) {
				try {
					b.addToolCall(ChatCompletionMessageToolCall.builder() //
							.id(c.getId()).function(Function.builder() //
									.name(c.getTool().getId()) //
									.arguments(JsonSchema.serialize(c.getArguments())) //
									.build()) //
							.build());
				} catch (JsonProcessingException e) {
					// Rethrows as runtime exception; in Python you do not need to know since you do
					// not need to declare exceptions in methods
					throw new RuntimeException(e);
				}
			}

			// There is nothing else to return since in this case the message will only have
			// calls.
			return List.of(ChatCompletionMessageParam.ofAssistant(b.build())); //
		}

		if (msg.hasToolCallResults()) {

			// The message contains some call results that we translate into corresponding
			// ChatCompletionMessageParam
			List<ChatCompletionMessageParam> result = new ArrayList<>();
			List<ToolCallResult> results = msg.getToolCallResults();
			for (ToolCallResult r : results) {
				result.add(ChatCompletionMessageParam.ofTool( //
						ChatCompletionToolMessageParam.builder() //
								.content(r.getResult().toString()) //
								.toolCallId(r.getToolCallId()).build() //
				));
			}

			// There is nothing else to return since in this case the message will only have
			// call results.
			return result;
		}

		// In all other cases, we expect a simple text message
		if (msg.isText()) {
			if (msg.getParts().size() != 1)
				throw new IllegalArgumentException(
						"Message can be only be simple text, a tool call, or tool call results");

			// Return corresponding ChatCompletionMessageParam
			switch (msg.getAuthor()) {
			case USER:
				return List.of(ChatCompletionMessageParam.ofUser( //
						ChatCompletionUserMessageParam.builder().content(msg.getTextContent()).build() //
				));
			case DEVELOPER:
				return List.of(ChatCompletionMessageParam.ofDeveloper( //
						ChatCompletionDeveloperMessageParam.builder().content(msg.getTextContent()).build() //
				));
			case BOT:
				return List.of(ChatCompletionMessageParam.ofAssistant( //
						ChatCompletionAssistantMessageParam.builder().content(msg.getTextContent()).build() //
				));
			default:
				throw new IllegalArgumentException("Message author not supported: " + msg.getAuthor());
			}
		}

		throw new IllegalArgumentException("Message can be only be simple text, a tool call, or tool call results");
	}

	/**
	 * @return A ResponseFormat that can be used to create a
	 *         ChatCompletionCreateParams to call OpenAI Chat Completion API.
	 */
	private ChatCompletionCreateParams.ResponseFormat createResponseFormat() {

		try {
			return ResponseFormat.ofJsonSchema( //
					ResponseFormatJsonSchema.builder() //
							.jsonSchema( //
									ResponseFormatJsonSchema.JsonSchema.builder() //
											.name("Anonymous") //
											.description("No Description") //
											.schema(JsonSchema.deserialize(getResponseFormat(), Schema.class)) //
											.build() //
							).build());
		} catch (JsonProcessingException e) {
			// Rethrows as runtime exception; in Python you do not need to know since you do
			// not need to declare exceptions in methods
			throw new RuntimeException(e);
		}
	}

	/**
	 * @return A List<ChatCompletionTool> that can be used to create a
	 *         ChatCompletionCreateParams to call OpenAI Chat Completion API. The
	 *         list will contain definitions for all the tools this agent can use.
	 */
	private List<ChatCompletionTool> createToolDefinitions() {

		List<Tool> tools = new ArrayList<>(toolMap.values());
		List<ChatCompletionTool> tls = new ArrayList<>(tools.size());
		for (Tool t : tools) {
			ChatCompletionTool f;
			try {
				f = ChatCompletionTool.builder() //
						.function( //
								FunctionDefinition.builder() //
										.name(t.getId()) //
										.description(t.getDescription()) //
										.strict(false) //
										.parameters(
												JsonSchema.deserialize(t.getJsonParameters(), FunctionParameters.class))
										.build() //
						).build();
			} catch (JsonProcessingException e) {
				// Rethrows as runtime exception; in Python you do not need to know since you do
				// not need to declare exceptions in methods
				throw new RuntimeException(e);
			}
			tls.add(f);
		}

		return tls;
	}

	/**
	 * Closes the agent freeing up resources.
	 */
	public void close() {
		for (Tool t : toolMap.values()) {
			try {
				t.close();
			} catch (Exception e) {
			}
		}

		try {
			client.close();
		} catch (Exception e) {
		}
	}

	public static class Format {
		@JsonProperty(required = true)
		@JsonPropertyDescription("Your output message")
		public String out;
	}

	public static void main(String[] args) {
		Agent bot = null;
		try {
			bot = new Agent();
			bot.setPersonality(
					"Always output messages as described by this schema: " + JsonSchema.getJsonSchema(Format.class));
			bot.setResponseFormat(Format.class);

			System.out.println(bot.chat("Ciao!").getText());
		} catch (Exception e) {
			e.printStackTrace(System.err);
		} finally {
			if (bot != null)
				try {
					bot.close();
				} catch (Exception e) {
				}
		}
	}
}

## ChatCompletion.java

package core;

import com.fasterxml.jackson.core.JsonProcessingException;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.SuperBuilder;

/**
 * This class encapsulates the response from a LLM (as a {@link ChatMessage}).
 * 
 * In addition, this also contains a reason why the response terminated.
 * 
 * @author Massimiliano "Maxi" Zattera.
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@RequiredArgsConstructor
@SuperBuilder
@Getter
@Setter
@ToString
public class ChatCompletion {

	/**
	 * This enumeration describes possible ways in which a language model completed
	 * its output.
	 * 
	 * @author Massimiliano "Maxi" Zattera.
	 */
	public enum FinishReason {

		/**
		 * Text generation is not yet completed, model might be returning a partial
		 * result (e.g. to allow streaming).
		 */
		IN_PROGRESS,

		/**
		 * Text generation has successfully terminated and the text is complete.
		 */
		COMPLETED,

		/**
		 * Text generation is finished, but the text was truncated, probably for
		 * limitations in model output length.
		 */
		TRUNCATED,

		/**
		 * Text content was in part or completely omitted due to content filters (e.g.
		 * profanity filter)
		 */
		INAPPROPRIATE,

		/** All finish reasons that do not fit in any other value */
		OTHER;
	}

	@NonNull
	private FinishReason finishReason;

	@NonNull
	private ChatMessage message;

	/**
	 * 
	 * @return A string representation of the returned message..
	 */
	public String getText() {
		return message.getTextContent();
	}

	/**
	 * 
	 * @return The content of this message as an instance of given class. This
	 *         assumes {@link #getText()} will return a properly formatted JSON
	 *         representation of the object.
	 * 
	 * @throws JsonProcessingException If an error occurs while parsing the message
	 *                                 content.
	 */
	public <T> T getObject(Class<T> c) throws JsonProcessingException {
		return JsonSchema.deserialize(getText(), c);
	}
}

## ChatMessage.java

package core;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.core.JsonProcessingException;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;

/**
 * This is a message exchanged with  an {@link Agent}.
 * 
 * Messages are formed by a list of {@link MessagePart}s; each part can provide
 * different contents (e.g. some text, a tool invocation
 * and its results, etc.).
 * 
 * @author Massmiliano "Maxi" Zattera.
 *
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@RequiredArgsConstructor
@Getter
@Setter
@ToString
public class ChatMessage {

	/**
	 * The author (originator) of the message.
	 */
	public enum Author {

		/** Marks messages coming from the user */
		USER("user"),

		/** Marks messages coming from the bot/agent/assistant */
		BOT("bot"),

		/**
		 * Marks messages coming from the developer. For some models, this is used to
		 * provide instructions to the model
		 */
		DEVELOPER("developer");

		private final String label;

		private Author(String label) {
			this.label = label;
		}

		@Override
		@JsonValue
		public String toString() { // Notice we rely on labels not to change
			return label;
		}
	}

	@NonNull
	private Author author;

	@NonNull
	private List<MessagePart> parts = new ArrayList<>();

	public void setParts(List<? extends MessagePart> parts) {
		this.parts.addAll(parts);
	}

	public ChatMessage(String content) {
		this(Author.USER, content);
	}

	public ChatMessage(@NonNull MessagePart part) {
		this(Author.USER, part);
	}

	public ChatMessage(@NonNull List<? extends MessagePart> parts) {
		this(Author.USER, parts);
	}

	public ChatMessage(@NonNull Author author, String content) {
		this.author = author;
		if (content != null)
			parts.add(new TextPart(content));
	}

	public ChatMessage(@NonNull Author author, @NonNull MessagePart part) {
		this.author = author;
		this.parts.add(part);
	}

	public ChatMessage(@NonNull Author author, @NonNull List<? extends MessagePart> parts) {
		this.author = author;
		this.parts.addAll(parts);
	}

	/**
	 * 
	 * @return True if and only if this message is pure text.
	 */
	public boolean isText() {
		for (MessagePart part : parts)
			if (!(part instanceof TextPart))
				return false;
		return true;
	}

	/**
	 * 
	 * @return True if this message contains at least one part which is text.
	 */
	public boolean hasText() {
		for (MessagePart part : parts)
			if (part instanceof TextPart)
				return true;
		return false;
	}

	/**
	 * 
	 * @return A string representation of the content of this message. Notice the
	 *         message could contain parts which are not easily representable as
	 *         text (e.g. a file). See {@link #isText()}.
	 */
	public String getTextContent() {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < parts.size(); ++i) {
			if (i > 0)
				result.append("\n\n");
			result.append(parts.get(i).getContent());
		}
		return result.toString();
	}

	/**
	 * 
	 * @return The content of this message as an instance of given class. This
	 *         assumes {@link #getTextContent()} will return a properly formatted
	 *         JSON representation of the object.
	 * 
	 * @throws JsonProcessingException If an error occurs while parsing the message
	 *                                 content.
	 */
	public <T> T getObjectContent(Class<T> c) throws JsonProcessingException {
		return JsonSchema.deserialize(getTextContent(), c);
	}

	/**
	 * 
	 * @return True if this message contains at least one invocation of a tool.
	 */
	public boolean hasToolCalls() {
		for (MessagePart part : parts)
			if (part instanceof ToolCall)
				return true;
		return false;
	}

	/**
	 * 
	 * @return All tool invocations contained in this message.
	 */
	public List<ToolCall> getToolCalls() {
		return parts.stream() //
				.filter(ToolCall.class::isInstance) //
				.map(ToolCall.class::cast) //
				.collect(Collectors.toList());
	}

	/**
	 * 
	 * @return True if this message contains at least one tool call response.
	 */
	public boolean hasToolCallResults() {
		for (MessagePart part : parts)
			if (part instanceof ToolCallResult)
				return true;
		return false;
	}

	/**
	 * 
	 * @return All tool invocations contained in this message.
	 */
	public List<ToolCallResult> getToolCallResults() {
		return parts.stream() //
				.filter(ToolCallResult.class::isInstance) //
				.map(ToolCallResult.class::cast) //
				.collect(Collectors.toList());
	}
}

## FuntionCallsExample.java

package core;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Scanner;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.kjetland.jackson.jsonSchema.annotations.JsonSchemaDescription;

import lombok.NonNull;

public class FunctionCallExample {

	static Random RND = new Random();

	// This is a tool that will be accessible to the agent
	// Notice it must be public.
	public static class GetCurrentWeatherTool extends AbstractTool {

		@JsonSchemaDescription("This is a class describing parameters for GetCurrentWeatherTool")
		public static class Parameters {

			private enum TemperatureUnits {
				CELSIUS, FARENHEIT
			};

			@JsonProperty(required = true)
			@JsonPropertyDescription("The city and state, e.g. San Francisco, CA.")
			public String location;

			@JsonPropertyDescription("Temperature unit (CELSIUS or FARENHEIT), defaults to CELSIUS")
			public TemperatureUnits unit;
		}

		public GetCurrentWeatherTool() throws JsonProcessingException {
			super("getCurrentWeather", // Function name
					"Get the current weather in a given city.", // Function description
					Parameters.class); // Function parameters
		}

		@Override
		public ToolCallResult invoke(@NonNull ToolCall call) throws Exception {

			// Tool implementation goes here.
			// In this example we simply return a random temperature.

			if (!isInitialized())
				throw new IllegalStateException("Tool must be initialized.");

			String location = getString("location", call.getArguments());
			return new ToolCallResult(call, "Temperature in " + location + " is " + (RND.nextInt(10) + 20) + "°C");
		}
	} // GetCurrentWeatherTool class

	public static void main(String[] args) throws Exception {

		Agent agent = new Agent("MyId", "No Description", List.of(new GetCurrentWeatherTool()));
		agent.setPersonality("You are an helpful assistant.");

		// Conversation loop
		try (Scanner console = new Scanner(System.in)) {
			while (true) {
				System.out.print("User     > ");
				String s = console.nextLine();

				ChatCompletion reply = agent.chat(s);

				// Check if agent generated a function call
				while (reply.getMessage().hasToolCalls()) {

					List<ToolCallResult> results = new ArrayList<>();

					// TODO Urgent: display any content that is not a tool call.
					// Add a method to get all and only concatenated text?

					for (ToolCall call : reply.getMessage().getToolCalls()) {

						// Print call for illustrative purposes
						System.out.println("CALL " + " > " + call);

						// Execute call, handling errors nicely
						ToolCallResult result;
						try {
							result = call.execute();
						} catch (Exception e) {
							result = new ToolCallResult(call, e);
						}
						results.add(result);
					}

					// Pass results back to the agent
					// Notice this might in principle generate
					// other tool calls, hence the loop
					reply = agent.chat(new ChatMessage(results));

				} // while we serviced all calls

				System.out.println("Assistant> " + reply.getText());
			}
		}
	}
}

## JsonSchema.java

package core;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.kjetland.jackson.jsonSchema.JsonSchemaGenerator;

/**
 * The class provide methods to :
 * 
 * 1. Obtain a JSON schema from a class.
 * 
 * 2. Serialise an instance of a class into JSON.
 * 
 * 3. De-serialise the JSON representation of a class.
 *
 * The class fully supports Jackson annotations when creating a schema fro a
 * class.
 * 
 * @see <a href=
 *      "https://json-schema.org/understanding-json-schema">Understanding JSON
 *      Schema</a>
 * 
 * @author Massimiliano "Maxi" Zattera
 */
public class JsonSchema {

	/** Used for creating JSON schema out of classes */
	private final static JsonSchemaGenerator SCHEMA_GENERATOR = new JsonSchemaGenerator(new ObjectMapper());

	/**
	 * Mapper provided for JSON serialisation via Jackson, if needed. Use this to
	 * deserialized objects that have been created through some schema.
	 */
	private static final ObjectMapper JSON_MAPPER;
	static {
		JSON_MAPPER = new ObjectMapper();
		JSON_MAPPER.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		JSON_MAPPER.setSerializationInclusion(JsonInclude.Include.NON_NULL);
	}

	// The below method uses JsonSchemaGenerator and Jacksoon annotations to create
	// a JSON schema fro the class. Use pydantic and its annotations to achieve same
	// result.
	
	/**
	 * @return JSON schema for the class c.
	 * @throws JsonProcessingException
	 */
	public static <T> String getJsonSchema(Class<T> c) {
		try {
			return JSON_MAPPER.writeValueAsString(SCHEMA_GENERATOR.generateJsonSchema(c));
		} catch (JsonProcessingException e) {
			return null; // Should never happen
		}
	}

	// Below Java methods can easily be translated in Python by using pydantic:
	//
	// from typing import Type, TypeVar
	// from pydantic import BaseModel
	//
	// T = TypeVar("T", bound=BaseModel)
	//
	//
	// # ---------- generic helpers ----------
	// def serialize(obj: BaseModel) -> str:
	// """Return *obj* as a JSON string, omitting fields whose value is None."""
	// return obj.json(exclude_none=True)
	//
	//
	// def deserialize(json_str: str, cls: Type[T]) -> T:
	// """Parse *json_str* into an instance of *cls*, ignoring unknown keys."""
	// return cls.parse_raw(json_str)
	// # -------------------------------------

	/**
	 * @return The Object o serialised as a JSON string.
	 */
	public static <T> String serialize(Object o) throws JsonProcessingException {
		return JSON_MAPPER.writeValueAsString(o);
	}

	/**
	 * @param json An object of type T serialised using JSON.
	 * @return An instance of T, corresponding to the object that is provided as
	 *         JSON object.
	 * @throws JsonProcessingException
	 * @throws JsonMappingException
	 */
	public static <T> T deserialize(String json, Class<T> c) throws JsonProcessingException {
		return JSON_MAPPER.readValue(json, c);
	}

	/**
	 * @param json An object of type T serialised using JSON.
	 * @return An instance of T, corresponding to the object that is provided as
	 *         JSON object.
	 */
	public static <T> T deserialize(String json, TypeReference<T> c) throws JsonProcessingException {
		return JSON_MAPPER.readValue(json, c);
	}

	public static void main(String[] args) {
		System.out.println(JsonSchema.getJsonSchema(FunctionCallExample.GetCurrentWeatherTool.Parameters.class));
	}
}

## MessagePart.java

package core;

/**
 * Marker interface for classes that can be parts of a {@link ChatMessage}.
 * 
 * 
 * @author Massimiliano "Maxi" Zattera.
 */
public interface MessagePart {

	/**
	 * 
	 * @return A string representation of the content of this message part. Notice
	 *         not all parts are easily representable as text (e.g. a file).
	 */
	String getContent();
}


## TextPart.java

package core;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.SuperBuilder;

/**
 * This is a {@link MessagePart} that contains only text.
 * 
 * @author Massimiliano "Maxi" Zattera.
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@RequiredArgsConstructor
@SuperBuilder
@ToString
public class TextPart implements MessagePart {

	@Getter
	@Setter
	private @NonNull String content;
}


## Tool.java

package core;

import lombok.NonNull;

/**
 * This is a tool that an {@link Agent} can invoke to perform a task.
 * Tool life cycle involves tool been initialized once before it is called and closed when it is no longer needed.
 * 
 * @author Massimiliano "Maxi" Zattera.
 *
 */
public interface Tool {

	/**
	 * Unique identifier for the tool; this is used as tool ID in API calls normally.
	 * 
	 * @return
	 */
	String getId();

	/**
	 * 
	 * @return A verbose description of what the tool does does, so that the agent
	 *         knows when to call it.
	 */
	String getDescription();

	/**
	 * 
	 * @return JSON Schema describing the parameters for the tool.
	 */
	String getJsonParameters();

	/**
	 * 
	 * @return True if the tool was already initialized.
	 */
	boolean isInitialized();

	/**
	 * 
	 * @return True if the tool was already closed.
	 */
	boolean isClosed();

	/**
	 * This must be called by the agent once and only once before any invocation to
	 * this tool.
	 * 
	 * @param agent The agent that is using this tool.
	 */
	void init(@NonNull Agent agent);

	/**
	 * Invokes (executes) the tool. This can be called several times.
	 * 
	 * @param call The call to the tool, created by the calling agent.
	 * 
	 * @return The result of calling the tool.
	 * 
	 * @param RuntimeException if the tool was not yet initialized.
	 */
	ToolCallResult invoke(@NonNull ToolCall call) throws Exception;
	
	/**
	 * Closes the tool when it is no longer needed.
	 */
    void close() throws Exception;
}

## ToolCall.java

package core;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;

/**
 * {@link Agent}s can invoke tools. This interface represents a single tool
 * invocation, as part of a message.
 * 
 * @author Massimiliano "Maxi" Zattera
 *
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@RequiredArgsConstructor
@Getter
@Setter
@ToString
public class ToolCall implements MessagePart {

	/**
	 * Builder
	 * 
	 * @author Luna
	 */
	public static final class Builder {
		private String id;
		private Tool tool;
		private Map<String, Object> arguments = new HashMap<>();

		public Builder id(@NonNull String id) {
			this.id = id;
			return this;
		}

		public Builder tool(@NonNull Tool tool) {
			this.tool = tool;
			return this;
		}

		/** Accepts any map whose values extend Object. */
		public Builder arguments(@NonNull Map<String, ? extends Object> args) {
			this.arguments = new HashMap<>(args);
			return this;
		}

		/**
		 * Parse a JSON string into the arguments map.
		 * 
		 * @throws JsonProcessingException
		 */
		public Builder arguments(@NonNull String json) throws JsonProcessingException {

			this.arguments = JsonSchema.deserialize(json, new TypeReference<Map<String, Object>>() {
			});
			return this;
		}

		public ToolCall build() {
			ToolCall tc = new ToolCall();
			tc.setId(Objects.requireNonNull(id, "id must not be null"));
			tc.setTool(Objects.requireNonNull(tool, "tool must not be null"));
			tc.setArguments(arguments);
			return tc;
		}
	}

	public static Builder builder() {
		return new Builder();
	}
	
	/**
	 * Unique ID for this tool call.
	 */
	@NonNull
	private String id;

	/**
	 * The tool being called. Notice it is not always guaranteed this to be set
	 * correctly, as some services might not be able to retrieve the proper Tool
	 * instance; this depends on the service generating the call. If this field is
	 * null, developers need to map this call to the proper tool externally from the
	 * service.
	 */
	private Tool tool;

	/**
	 * Arguments to use in the call, as name/value pairs.
	 */
	@NonNull
	private Map<String, Object> arguments = new HashMap<>();

	@Override
	public String getContent() {
		return toString();
	}

	/**
	 * Executes this call. Notice this will work only if {{@link #getTool()} returns
	 * a valid tool.
	 * 
	 * @return Result of invoking the tool.
	 * @throws Exception If an error occurs while executing the call.
	 */
	public ToolCallResult execute() throws Exception {
		return getTool().invoke(this);
	}
}

## ToolCallResult.java

package core;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.SuperBuilder;

/**
 * This holds the results of a {@link ToolCall}. It is used to pass results from
 * tool execution back to the calling agent.
 * 
 * @author Massimiliano "Maxi" Zattera.
 *
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@RequiredArgsConstructor
@SuperBuilder
@Getter
@Setter
@ToString
public class ToolCallResult implements MessagePart {

	/** Unique ID for corresponding tool invocation. */
	@NonNull
	private String toolCallId;

	/** Unique ID of the tool being called. */
	// TODO Needed?
	@NonNull
	private String toolId;

	/** Result of calling the tool. */
	private String result;

	/** True if the result is an error. */
	@Builder.Default
	private boolean isError = false;

	public ToolCallResult(@NonNull ToolCall call, String result) {
		toolCallId = call.getId();
		toolId = call.getTool().getId();
		this.result = result;
	}

	public ToolCallResult(String toolCallId, String toolId, String result) {
		this.toolCallId = toolCallId;
		this.toolId = toolId;
		this.result = result;
	}
	
	public ToolCallResult(ToolCall call, Exception e) {
		this(call, "Error: " + e.getMessage());
		isError = true;
	}

	@Override
	public String getContent() {
		return ("ToolCallResult(" + (isError ? "*ERROR* " : "") + (result == null ? "" : result.toString()) + ")");
	}

}

</java>

<python>

## JsonSchema

from __future__ import annotations

import json
from typing import Type, TypeVar
from pydantic import BaseModel, TypeAdapter

T = TypeVar("T", bound=BaseModel)

class JsonSchema:
    """
    Python version of the Java JsonSchema utility class.
    Provides methods for:
    1. Getting a JSON schema from a Pydantic model.
    2. Serializing a Pydantic model instance to JSON.
    3. Deserializing a JSON string to a Pydantic model instance.
    """

    @staticmethod
    def get_json_schema(cls: type[BaseModel]) -> str:
        """
        Returns the JSON schema (draft-07) for the given Pydantic model class.

        Args:
            cls: The Pydantic model class.

        Returns:
            A string containing the JSON schema for the class.
        """
        return json.dumps(cls.model_json_schema(), separators=(",", ":"))

    @staticmethod
    def serialize(obj: BaseModel) -> str:
        """
        Serializes a Pydantic model instance to a JSON string, omitting fields whose value is None.

        Args:
            obj: The Pydantic model instance.

        Returns:
            The JSON string representation of the model.
        """
        return obj.model_dump_json(exclude_none=True)

    @staticmethod
    def deserialize(json_str: str, cls: Type[T]) -> T:
        """
        Deserializes a JSON string into an instance of the specified Pydantic model class,
        ignoring unknown fields.

        Args:
            json_str: The JSON string to deserialize.
            cls: The Pydantic model class.

        Returns:
            An instance of the specified model class.
        """
        adapter = TypeAdapter(cls)
        return adapter.validate_json(json_str, strict=False)
        
## Tool & AbstractTool

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from typing import Any, Mapping, Type

# --------------------------------------------------------------------------- #
# Logging configuration (equivalent to Java SimpleLogger)
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------- #
# Forward references to avoid circular imports
# --------------------------------------------------------------------------- #
if False:  # type-checking only
    from agent import Agent
    from tool_call import ToolCall
    from tool_call_result import ToolCallResult

from json_schema import JsonSchema  # noqa: E402  (local project import)


# --------------------------------------------------------------------------- #
# Tool ­– Python equivalent of the Java interface
# --------------------------------------------------------------------------- #
class Tool(ABC):
    """
    Base protocol for every tool the agent can call.
    Sub-classes must implement :meth:`invoke`.
    """

    # --------------------------------------------------------------------- #
    # Public attributes expected by the agent
    # --------------------------------------------------------------------- #
    id: str
    description: str
    json_parameters: str

    # --------------------------------------------------------------------- #
    # Life-cycle hooks
    # --------------------------------------------------------------------- #
    @abstractmethod
    def is_initialized(self) -> bool: ...

    @abstractmethod
    def is_closed(self) -> bool: ...

    @abstractmethod
    def init(self, agent: "Agent") -> None: ...

    # --------------------------------------------------------------------- #
    # Core functionality
    # --------------------------------------------------------------------- #
    @abstractmethod
    def invoke(self, call: "ToolCall") -> "ToolCallResult": ...

    @abstractmethod
    def close(self) -> None: ...


# --------------------------------------------------------------------------- #
# AbstractTool ­– shared implementation for concrete tools
# --------------------------------------------------------------------------- #
class AbstractTool(Tool):
    """
    Convenient super-class that handles common responsibilities:
    * life-cycle management (`init`, `close`)
    * JSON-schema generation for parameters
    * helper methods to parse arguments passed as strings

    Parameters
    ----------
    id_ : str
        Unique identifier for the tool (used by the agent and the model).
    description : str, optional
        Human-readable description of the tool’s purpose.
    parameters_cls : type
        A class (typically a *pydantic* model) describing the tool parameters.
        Its JSON schema is exposed through :pyattr:`json_parameters`.
    """

    # --------------------------------------------------------------------- #
    # Construction & life-cycle
    # --------------------------------------------------------------------- #
    def __init__(
        self,
        id_: str,
        description: str | None = None,
        parameters_cls: Type | None = None,
    ) -> None:
        if id_ is None:
            raise ValueError("id_ must not be None")
        if description is None:
            raise ValueError("description must not be None")
        if parameters_cls is None:
            raise ValueError("parameters_cls must not be None")

        self.id: str = id_
        self.description: str = description
        self.json_parameters: str = JsonSchema.get_json_schema(parameters_cls)

        self._agent: "Agent | None" = None
        self._closed: bool = False

    # --------------------------------------------------------------------- #
    # Life-cycle helpers
    # --------------------------------------------------------------------- #
    def is_initialized(self) -> bool:
        return self._agent is not None

    def is_closed(self) -> bool:
        return self._closed

    def init(self, agent: "Agent") -> None:
        if agent is None:
            raise ValueError("agent must not be None")
        if self.is_initialized():
            raise RuntimeError(f"Tool {self.id} is already initialized")
        if self.is_closed():
            raise RuntimeError(f"Tool {self.id} is already closed")

        self._agent = agent
        logger.debug("Tool %s initialised", self.id)

    def close(self) -> None:
        self._closed = True
        logger.debug("Tool %s closed", self.id)

    # --------------------------------------------------------------------- #
    # Static helpers for argument parsing
    # --------------------------------------------------------------------- #
    @staticmethod
    def get_boolean(name: str, args: Mapping[str, Any], default: bool | None = None) -> bool:
        if name not in args:
            if default is not None:
                return default
            raise ValueError(f'Missing required parameter "{name}".')

        value = args[name]
        if isinstance(value, bool):
            return value
        if isinstance(value, str):
            s = value.strip().lower()
            if s == "true":
                return True
            if s == "false":
                return False

        raise ValueError(f'Parameter "{name}" is expected to be a boolean value but it is not.')

    @staticmethod
    def get_long(name: str, args: Mapping[str, Any], default: int | None = None) -> int:
        if name not in args:
            if default is not None:
                return default
            raise ValueError(f'Missing required parameter "{name}".')

        try:
            return int(args[name])
        except Exception as exc:  # noqa: BLE001
            raise ValueError(f'Parameter "{name}" is expected to be an integer value but it is not.') from exc

    @staticmethod
    def get_double(name: str, args: Mapping[str, Any], default: float | None = None) -> float:
        if name not in args:
            if default is not None:
                return default
            raise ValueError(f'Missing required parameter "{name}".')

        try:
            return float(args[name])
        except Exception as exc:  # noqa: BLE001
            raise ValueError(f'Parameter "{name}" is expected to be a decimal number but it is not.') from exc

    @staticmethod
    def get_string(name: str, args: Mapping[str, Any], default: str | None = None) -> str | None:
        if name not in args:
            return default
        value = args[name]
        return None if value is None else str(value)
        
## ChatMessage and related classes


"""chat_types.py

Auto‑generated Python translation of several Java classes:

- ChatCompletion
- ChatMessage (+ nested Author)
- MessagePart (interface)
- TextPart
- ToolCall (with fluent Builder)
- ToolCallResult
- FinishReason (nested in ChatCompletion)

The implementation follows the translation guidelines supplied:
* CamelCase → snake_case for identifiers.
* Lombok‑generated boiler‑plate is made explicit.
* Overloaded constructors mapped to a single __init__ with @overload helpers.
* Builder patterns translated into fluent interfaces.
* Java RuntimeException / IllegalArgumentException mapped to Python RuntimeError / ValueError.
* Logging uses Python’s stdlib 'logging' module.
* JSON (de)serialisation leverages the provided JsonSchema helper.

The module purposefully contains **no** external side‑effects.
"""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from collections.abc import Sequence
from typing import Any, Mapping, overload, Self, Type, TypeVar

from json_schema import JsonSchema

# Forward‑references to avoid circular imports at type‑checking time
if False:  # pragma: no cover
    from agent import Agent
    from tool import Tool  # AbstractTool & Tool live in the project
    from tool_call_result import ToolCallResult  # noqa: F401

# --------------------------------------------------------------------------- #
# Logging configuration (equivalent to Java SimpleLogger)
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------- #
# MessagePart – marker interface
# --------------------------------------------------------------------------- #
class MessagePart(ABC):
    """A piece of a :class:`ChatMessage`."""

    @abstractmethod
    def get_content(self) -> str:
        """Return a textual representation of this part (best‑effort)."""

    # ------------------------------------------------------------------ #
    # Pythonic alias
    # ------------------------------------------------------------------ #
    def __str__(self) -> str:  # pragma: no cover
        return self.get_content()


# --------------------------------------------------------------------------- #
# TextPart – simple textual message part
# --------------------------------------------------------------------------- #
class TextPart(MessagePart):
    """A :class:`MessagePart` containing plain text."""

    def __init__(self, content: str) -> None:
        if content is None:
            raise ValueError("content must not be None")
        self._content: str = str(content)

    # Property to honour @NonNull semantics
    @property
    def content(self) -> str:
        return self._content

    @content.setter
    def content(self, value: str) -> None:
        if value is None:
            raise ValueError("content must not be None")
        self._content = str(value)

    # MessagePart ------------------------------------------------------ #
    def get_content(self) -> str:
        return self._content


# --------------------------------------------------------------------------- #
# ToolCall – a single invocation of a Tool
# --------------------------------------------------------------------------- #
class ToolCall(MessagePart):
    """Represents a single invocation of a :class:`Tool`."""

    def __init__(
        self,
        id_: str,
        tool: "Tool",
        arguments: Mapping[str, Any] | None = None,
    ) -> None:
        if id_ is None:
            raise ValueError("id_ must not be None")
        if tool is None:
            raise ValueError("tool must not be None")

        self.id: str = id_
        self.tool: "Tool" = tool
        self.arguments: dict[str, Any] = dict(arguments or {})

    # ----------------------- builder helpers -------------------------- #
    class Builder:
        """Fluent builder replicating the Java pattern."""

        def __init__(self) -> None:
            self._id: str | None = None
            self._tool: "Tool | None" = None
            self._arguments: dict[str, Any] = {}

        # id
        def id(self, id_: str) -> Self:  # noqa: D401 (“Returns self”)
            if id_ is None:
                raise ValueError("id must not be None")
            self._id = id_
            return self

        # tool
        def tool(self, tool: "Tool") -> Self:  # noqa: D401
            if tool is None:
                raise ValueError("tool must not be None")
            self._tool = tool
            return self

        # arguments – mapping
        def arguments(self, args: Mapping[str, Any]) -> Self:  # noqa: D401
            if args is None:
                raise ValueError("args must not be None")
            self._arguments = dict(args)
            return self

        # arguments – JSON string
        def arguments_json(self, json_str: str) -> Self:  # noqa: D401
            from typing import TypeAlias
            import json as _json

            _Map: TypeAlias = dict[str, Any]
            self._arguments = JsonSchema.deserialize(json_str, _Map)  # type: ignore[type-var]
            return self

        # Build
        def build(self) -> "ToolCall":
            return ToolCall(
                id_=self._id or (lambda: (_ for _ in ()).throw(ValueError("id not set")))(),  # trick to raise
                tool=self._tool or (lambda: (_ for _ in ()).throw(ValueError("tool not set")))(),
                arguments=self._arguments,
            )

    # Mimic Java's static builder() method
    @staticmethod
    def builder() -> "ToolCall.Builder":
        return ToolCall.Builder()

    # ------------------------------------------------------------------ #
    # MessagePart
    # ------------------------------------------------------------------ #
    def get_content(self) -> str:
        return f"ToolCall(id={self.id}, tool={self.tool.id}, args={self.arguments})"

    # ------------------------------------------------------------------ #
    # Execution helper
    # ------------------------------------------------------------------ #
    def execute(self) -> "ToolCallResult":
        """Invoke the underlying tool and return its result."""
        if self.tool is None:
            raise RuntimeError("Cannot execute a ToolCall without a bound Tool")
        return self.tool.invoke(self)  # type: ignore[return-value]


# --------------------------------------------------------------------------- #
# ToolCallResult – holds the outcome of a ToolCall
# --------------------------------------------------------------------------- #
class ToolCallResult(MessagePart):
    """Result (or error) produced by a :class:`ToolCall`."""

    def __init__(
        self,
        tool_call_id: str,
        tool_id: str,
        result: str | None = None,
        is_error: bool = False,
    ) -> None:
        if tool_call_id is None:
            raise ValueError("tool_call_id must not be None")
        if tool_id is None:
            raise ValueError("tool_id must not be None")

        self.tool_call_id: str = tool_call_id
        self.tool_id: str = tool_id
        self.result: str | None = result
        self.is_error: bool = is_error

    # Convenience constructors matching Java behaviour ----------------- #
    @classmethod
    def from_call(cls, call: ToolCall, result: str | None) -> "ToolCallResult":
        return cls(call.id, call.tool.id, result)

    @classmethod
    def from_exception(cls, call: ToolCall, exc: Exception) -> "ToolCallResult":
        return cls(call.id, call.tool.id, f"Error: {exc}", is_error=True)

    # ------------------------------------------------------------------ #
    # MessagePart
    # ------------------------------------------------------------------ #
    def get_content(self) -> str:
        label = "*ERROR* " if self.is_error else ""
        body = "" if self.result is None else str(self.result)
        return f"ToolCallResult({label}{body})"


# --------------------------------------------------------------------------- #
# ChatMessage – exchanged between user and agent
# --------------------------------------------------------------------------- #
class ChatMessage:
    """A single chat message, possibly composed of multiple parts."""

    # --------------------------- author -------------------------------- #
    class Author(str):
        """Enumeration of possible message authors."""

        USER = "user"
        BOT = "bot"
        DEVELOPER = "developer"

        def __new__(cls, value: str):
            return str.__new__(cls, value)

    # ------------------------- construction ---------------------------- #
    @overload
    def __init__(self, content: str, author: "ChatMessage.Author" = Author.USER) -> None: ...
    @overload
    def __init__(self, part: MessagePart, author: "ChatMessage.Author" = Author.USER) -> None: ...
    @overload
    def __init__(
        self,
        parts: Sequence[MessagePart],
        author: "ChatMessage.Author" = Author.USER,
    ) -> None: ...

    def __init__(
        self,
        first: str | MessagePart | Sequence[MessagePart],
        author: "ChatMessage.Author" = Author.USER,
    ) -> None:
        if author is None:
            raise ValueError("author must not be None")

        self.author: ChatMessage.Author = author
        self.parts: list[MessagePart] = []

        # Normalise input
        if isinstance(first, str):
            self.parts.append(TextPart(first))
        elif isinstance(first, MessagePart):
            self.parts.append(first)
        else:  # iterable of parts
            self.parts.extend(first)

    # ------------------------------------------------------------------ #
    # Public helpers (mirroring Java API)
    # ------------------------------------------------------------------ #
    def is_text(self) -> bool:
        """Return *True* iff every part is a :class:`TextPart`."""
        return all(isinstance(p, TextPart) for p in self.parts)

    def has_text(self) -> bool:
        return any(isinstance(p, TextPart) for p in self.parts)

    def get_text_content(self) -> str:
        return "\n\n".join(p.get_content() for p in self.parts)

    T_co = TypeVar("T_co")

    def get_object_content(self, cls: Type[T_co]) -> T_co:
        return JsonSchema.deserialize(self.get_text_content(), cls)

    # --- tool‑calls ---------------------------------------------------- #
    def has_tool_calls(self) -> bool:
        from tool_call import ToolCall  # local import to avoid cyclic deps

        return any(isinstance(p, ToolCall) for p in self.parts)

    def get_tool_calls(self) -> list["ToolCall"]:
        from tool_call import ToolCall  # local import to avoid cyclic deps

        return [p for p in self.parts if isinstance(p, ToolCall)]

    def has_tool_call_results(self) -> bool:
        from tool_call_result import ToolCallResult  # local import

        return any(isinstance(p, ToolCallResult) for p in self.parts)

    def get_tool_call_results(self) -> list["ToolCallResult"]:
        from tool_call_result import ToolCallResult  # local import

        return [p for p in self.parts if isinstance(p, ToolCallResult)]

    # ------------------------------------------------------------------ #
    # Representation helpers
    # ------------------------------------------------------------------ #
    def __str__(self) -> str:  # pragma: no cover
        return f"{self.author}: {self.get_text_content()}"

    __repr__ = __str__


# --------------------------------------------------------------------------- #
# ChatCompletion – wraps a model’s reply
# --------------------------------------------------------------------------- #
class ChatCompletion:
    """Encapsulates the reply produced by a language‑model."""

    # --------------------------- finish reasons ------------------------ #
    class FinishReason(str):
        IN_PROGRESS = "in_progress"
        COMPLETED = "completed"
        TRUNCATED = "truncated"
        INAPPROPRIATE = "inappropriate"
        OTHER = "other"

        def __new__(cls, value: str):
            return str.__new__(cls, value)

    # --------------------------- life‑cycle ---------------------------- #
    def __init__(
        self,
        finish_reason: "ChatCompletion.FinishReason",
        message: ChatMessage,
    ) -> None:
        if finish_reason is None:
            raise ValueError("finish_reason must not be None")
        if message is None:
            raise ValueError("message must not be None")

        self.finish_reason: ChatCompletion.FinishReason = finish_reason
        self.message: ChatMessage = message

    # ------------------------------------------------------------------ #
    # Convenience
    # ------------------------------------------------------------------ #
    def get_text(self) -> str:
        return self.message.get_text_content()

    T_co = TypeVar("T_co")

    def get_object(self, cls: Type[T_co]) -> T_co:
        """Parse the textual content as JSON into *cls*."""
        return self.message.get_object_content(cls)

## Agent

"""agent.py

Python translation of the Java `Agent` class.

The implementation mirrors the original behaviour while embracing Pythonic
conventions and the `openai` Python SDK.

Dependencies
------------
- openai                (official OpenAI SDK)
- json                  (standard library)
- logging               (standard library)
- chat_types.ChatMessage, chat_types.ChatCompletion,
  chat_types.ToolCall, chat_types.ToolCallResult, chat_types.TextPart
- tool.Tool             (protocol / abstract base class for tools)
- json_schema.JsonSchema
"""

from __future__ import annotations

import json
import logging
import os
from collections.abc import Iterable, Sequence
from typing import Any, Dict, List, Mapping, MutableMapping, Type

import openai

from chat_types import (
    ChatCompletion,
    ChatMessage,
    TextPart,
    ToolCall,
    ToolCallResult,
)
from json_schema import JsonSchema
from tool import Tool

# --------------------------------------------------------------------------- #
# Logging (equivalent to Java SimpleLogger)
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------- #
# Agent
# --------------------------------------------------------------------------- #
class Agent:
    """
    An *Agent* that uses OpenAI’s Chat Completions API.

    Parameters
    ----------
    id_ : str
        Unique identifier for the agent.
    description : str
        Human-readable description of the agent’s capabilities.
    tools : Iterable[Tool], optional
        Tools that the agent can invoke.
    """

    DEFAULT_MODEL: str = "gpt-4.1"

    # -------------------------- construction --------------------------- #
    def __init__(
        self,
        id_: str = "OpenAIChatCompletionService",
        description: str = "Test agent",
        tools: Iterable[Tool] | None = None,
    ) -> None:
        if id_ is None:
            raise ValueError("id_ must not be None")
        if description is None:
            raise ValueError("description must not be None")

        self.id: str = id_
        self.description: str = description

        # Tools --------------------------------------------------------- #
        self._tool_map: Dict[str, Tool] = {}
        for tool in tools or []:
            if tool is None:
                raise ValueError("tools must not contain None")
            tool.init(self)
            self._tool_map[tool.id] = tool

        # Conversation state ------------------------------------------- #
        self.history: List[ChatMessage] = []
        self.max_history_length: int = float("inf")  # no hard limit
        self.max_conversation_steps: int = float("inf")

        # Model configuration ------------------------------------------ #
        self.model: str = self.DEFAULT_MODEL
        self.temperature: float = 0.0
        self.personality: str | None = None
        self._response_format: str | None = None

        # OpenAI configuration ----------------------------------------- #
        # Expect OPENAI_API_KEY in the environment
        openai.api_key = os.getenv("OPENAI_API_KEY")

    # --------------------------- utils -------------------------------- #
    # Conversation helpers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    def clear_conversation(self) -> None:
        """Start a new chat (clears stored history)."""
        self.history.clear()

    # Personality / response-format ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    @property
    def response_format(self) -> str | None:
        return self._response_format

    def set_response_format(self, schema: Type) -> None:
        """Define an explicit JSON schema for model outputs."""
        if schema is None:
            raise ValueError("schema must not be None")
        self._response_format = JsonSchema.get_json_schema(schema)

    # --------------------- public chat API ---------------------------- #
    def chat(self, message: str | ChatMessage | Sequence[ChatMessage]) -> ChatCompletion:
        """
        Continue the ongoing conversation with *message*.

        The provided message(s) are appended to the conversation, the LLM is
        queried, and the reply is stored in the history.
        """
        # Normalise input
        if isinstance(message, str):
            new_messages = [ChatMessage(message)]
        elif isinstance(message, ChatMessage):
            new_messages = [message]
        else:
            new_messages = list(message)

        # Build conversation context
        conversation: List[ChatMessage] = list(self.history) + new_messages
        self._trim_conversation(conversation)

        # Call the model
        completion = self._chat_completion(conversation)

        # Update history (respecting max_history_length)
        self.history.extend(new_messages)
        self.history.append(completion.message)
        if len(self.history) > self.max_history_length:
            del self.history[: len(self.history) - self.max_history_length]

        return completion

    # ------------------------------------------------------------------ #
    # One-shot completion (ignores history) ---------------------------- #
    def complete(self, prompt: str | ChatMessage) -> ChatCompletion:
        """Run *prompt* outside the conversation (history is untouched)."""
        single = ChatMessage(prompt) if isinstance(prompt, str) else prompt
        conversation = [single]
        self._trim_conversation(conversation)
        return self._chat_completion(conversation)

    # -------------------------- internals ----------------------------- #
    # Trim conversation to honour limits and add personality ~~~~~~~~~~~ #
    def _trim_conversation(self, messages: List[ChatMessage]) -> None:
        """Mutate *messages* so it respects configured limits."""
        # Remove leading tool-results without matching calls
        while messages and messages[0].has_tool_call_results():
            messages.pop(0)

        # Enforce max steps
        if len(messages) > self.max_conversation_steps:
            del messages[: len(messages) - self.max_conversation_steps]

        if not messages:
            raise ValueError("No messages left in conversation after trimming")

        # Inject personality (developer role) as first message
        if self.personality:
            messages.insert(0, ChatMessage(self.personality, ChatMessage.Author.DEVELOPER))

    # Convert ChatMessage → OpenAI message dict ~~~~~~~~~~~~~~~~~~~~~~~~ #
    def _from_chat_message(self, msg: ChatMessage) -> List[Dict[str, Any]]:
        if msg.has_tool_calls():
            tool_calls = []
            for call in msg.get_tool_calls():
                tool_calls.append(
                    {
                        "id": call.id,
                        "type": "function",
                        "function": {
                            "name": call.tool.id,
                            "arguments": json.dumps(call.arguments, separators=(",", ":")),
                        },
                    }
                )
            return [{"role": "assistant", "content": None, "tool_calls": tool_calls}]

        if msg.has_tool_call_results():
            return [
                {
                    "role": "tool",
                    "tool_call_id": r.tool_call_id,
                    "content": r.result,
                }
                for r in msg.get_tool_call_results()
            ]

        # Plain text
        if not msg.is_text():
            raise ValueError("Message must be text, a tool call, or tool call results")

        role_map = {
            ChatMessage.Author.USER: "user",
            ChatMessage.Author.BOT: "assistant",
            ChatMessage.Author.DEVELOPER: "system",  # OpenAI 'developer' maps to 'system'
        }
        return [{"role": role_map[msg.author], "content": msg.get_text_content()}]

    # Convert OpenAI message → ChatMessage ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    def _from_openai_message(self, message: Mapping[str, Any]) -> ChatMessage:
        if "tool_calls" in message:
            calls: List[ToolCall] = []
            for tc in message["tool_calls"]:
                tool_id = tc["function"]["name"]
                tool = self._tool_map.get(tool_id)
                if tool is None:
                    raise ValueError(f"No tool registered with id '{tool_id}'")

                calls.append(
                    ToolCall(
                        id_=tc["id"],
                        tool=tool,
                        arguments=json.loads(tc["function"]["arguments"]),
                    )
                )
            return ChatMessage(ChatMessage.Author.BOT, calls)

        parts: List[TextPart] = []
        if content := message.get("content"):
            parts.append(TextPart(str(content)))
        if message.get("role") == "assistant" and message.get("content") is None:
            parts.append(TextPart("**The model generated an empty response**"))

        return ChatMessage(ChatMessage.Author.BOT, parts)

    # Prepare response_format / tools for OpenAI call ~~~~~~~~~~~~~~~~~~ #
    def _create_response_format(self) -> Dict[str, Any] | None:
        if self._response_format is None:
            return None
        return {
            "type": "json_object",
            "schema": json.loads(self._response_format),
        }

    def _create_tool_definitions(self) -> List[Dict[str, Any]] | None:
        if not self._tool_map:
            return None
        tools = []
        for t in self._tool_map.values():
            tools.append(
                {
                    "type": "function",
                    "function": {
                        "name": t.id,
                        "description": t.description,
                        "parameters": json.loads(t.json_parameters),
                    },
                }
            )
        return tools

    # Core: call OpenAI and wrap result ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    def _chat_completion(self, messages: Sequence[ChatMessage]) -> ChatCompletion:
        openai_messages: List[Dict[str, Any]] = []
        for m in messages:
            openai_messages.extend(self._from_chat_message(m))

        req: Dict[str, Any] = {
            "model": self.model,
            "messages": openai_messages,
            "temperature": self.temperature,
        }

        if (rf := self._create_response_format()) is not None:
            req["response_format"] = rf
        if (td := self._create_tool_definitions()) is not None:
            req["tools"] = td

        logger.info("OpenAI request: %s", req)

        resp = openai.ChatCompletion.create(**req)
        choice = resp.choices[0]
        finish_reason = self._map_finish_reason(choice.finish_reason)

        chat_message = self._from_openai_message(choice.message)
        return ChatCompletion(finish_reason, chat_message)

    # Finish-reason mapping ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    @staticmethod
    def _map_finish_reason(finish: str | None) -> ChatCompletion.FinishReason:
        mapping = {
            "stop": ChatCompletion.FinishReason.COMPLETED,
            "tool_calls": ChatCompletion.FinishReason.COMPLETED,
            "function_call": ChatCompletion.FinishReason.COMPLETED,
            "length": ChatCompletion.FinishReason.TRUNCATED,
            "content_filter": ChatCompletion.FinishReason.INAPPROPRIATE,
        }
        return mapping.get(finish, ChatCompletion.FinishReason.OTHER)

    # --------------------------- teardown ----------------------------- #
    def close(self) -> None:
        """Close all tools; nothing required for *openai* client."""
        for tool in self._tool_map.values():
            try:
                tool.close()
            except Exception:  # noqa: BLE001
                logger.exception("Error while closing tool %s", tool.id)


</python>