You are an agent assisting a developer in translating some Java code into Python.
The Java code is provided below, in <java> tag.

Your task is to translate these classes in Python: PersonLocatorAgent, ReactAgentTest, WeatherAgent; while you do it, you **MUST** **STRICTLY** follow the instructions below.

## Instructions

Read the code in <java> carefully before translating it into Python.
Java comments might contain directions about how to translate code in Python;  **STRICTLY** follow them if they are provided.
Some of the Java classes have already been translated into Python and they are provided in the <python> tag. If you need access to these class, provide the proper import directives in your Python code and assume the classes will be available; **STRICTLY** never use minimal fallback code.Be aware that the Java code uses Lombok annotations; you need to translate code generated by Lombok as well.
When translating Java fields and methods into Python, use proper naming convention (e.g. translate field names from camelCase into snake_case).
Always use type annotations (Python 3.6+).
When @NonNull is used in a method parameter, add code in the Python function that checks provided parameter value is not null.
Ignore the "final" attribute when converting from Java.
Translate RuntimeException as RuntimeError and IllegalArgumentException as ValueError.
**STRICTLY** always create comments in English; **NEVER** use Italian in your output.
**STRICTLY** ignore @JsonView annotation when translating into Python; behave like it is not there

### Logging

Java code uses Java libraries for logging (e.g. slf4j); when translating code to Python translate this by using equivalent methods in the logging standard library. For example:

```java
public class Agent {

	private final static Logger LOG = LoggerFactory.getLogger(Agent.class);

	...LOG.debug("Message");
```

Must be translated into somethign like:

```python
import logging

# configurationequivalent to Java SimpleLogger
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)

logger = logging.getLogger(__name__)  # as LoggerFactory.getLogger()

...


logger.debug("Message")

```



### Constructors

When translating Java overloaded constructors (which Python does not support), use one flexible __init__ plus a couple of convenience class-methods. This keeps the call-sites as short as in Java while complying with Python best-practice (PEP 8 naming, type hints, single source of truth).

For example, the below list of constructors for same class:

```java
public ChatMessage(String content) {
	this(Author.USER, content);
}

public ChatMessage(@NonNull MessagePart part) {
	this(Author.USER, part);
}

public ChatMessage(@NonNull List<? extends MessagePart> parts) {
	this(Author.USER, parts);
}

public ChatMessage(@NonNull Author author, String content) {
	this.author = author;
	if (content != null)
		parts.add(new TextPart(content));
}

public ChatMessage(@NonNull Author author, @NonNull MessagePart part) {
	this.author = author;
	this.parts.add(part);
}

public ChatMessage(@NonNull Author author, @NonNull List<? extends MessagePart> parts) {
	this.author = author;
	this.parts.addAll(parts);
}
```

Must be translated as:

```python
from __future__ import annotations
from collections.abc import Sequence
from typing import overload

class Author(str):
    USER = "user"
    SYSTEM = "system"
    # …

class MessagePart: ...
class TextPart(MessagePart):
    def __init__(self, content: str) -> None:
        self.content = content


class ChatMessage:
    """
    A port of the Java `ChatMessage` with the same semantics.

    Parameters
    ----------
    author : Author, default Author.USER
    parts  : • str                → wrapped in TextPart
             • MessagePart        → stored as-is
             • Sequence[MessagePart] → copied 1-to-1
    """
    # static type-checkers can still benefit from @overload
    @overload
    def __init__(self, content: str, author: Author = Author.USER) -> None: ...
    @overload
    def __init__(self, part: MessagePart, author: Author = Author.USER) -> None: ...
    @overload
    def __init__(
        self,
        parts: Sequence[MessagePart],
        author: Author = Author.USER,
    ) -> None: ...

    def __init__(
        self,
        first: str | MessagePart | Sequence[MessagePart],
        author: Author = Author.USER,
    ) -> None:
        self.author: Author = author
        self.parts: list[MessagePart] = []

        # --- normalise input -------------------------------------------------
        if isinstance(first, str):
            self.parts.append(TextPart(first))
        elif isinstance(first, MessagePart):
            self.parts.append(first)
        else:  # sequence of parts
            self.parts.extend(first)
        # ---------------------------------------------------------------------

    # ---------- alternate constructors (optional) ---------------------------
    @classmethod
    def from_content(cls, content: str, author: Author = Author.USER) -> "ChatMessage":
        return cls(content, author)

    @classmethod
    def from_part(cls, part: MessagePart, author: Author = Author.USER) -> "ChatMessage":
        return cls(part, author)
```

### Builder

The provided Java classes often use the Builder pattern either providing a Builder explicitly or using @Builder Lombok annotation.
In all of these cases, strictly use a “fluent interface” style pattern.

For example, this Java class:

```java
import lombok.Builder;
import lombok.Singular;
import lombok.Value;
import java.util.List;

@Builder             
public class PizzaOrder {

    @Builder.Default
    String size = "M";          

    @Singular
    List<String> toppings;      

    @Builder.Default
    boolean glutenFree = false; 
}
```

Must be translated in Python as follows:


```python
from dataclasses import dataclass, field
from typing import Self

@dataclass
class PizzaOrder:
    size: str = "M"
    toppings: list[str] = field(default_factory=list)
    gluten_free: bool = False

    # “fluent interface” style
    def with_size(self, size: str) -> Self:
        self.size = size
        return self

    def add_topping(self, name: str) -> Self:
        self.toppings.append(name)
        return self
```

### Getters and setters

Do not  translate literally java getters and setters in Python, rather follow the below logic:

  1. If no getter or setter is provided, make the field private using "_underscore naming"
  2. If any getter or setter is provided with Lombok annotations that is not private, then treat corresponding field as public in Python and give it direct attribute access. Do this regardless the access level for the getter/setter (e.g. if the getter is public and the setter is protected, treat the field as public).
  3. If any getter or setter is provided in Java with some logic, then use @property annotation in Python and translate corresponding Java logic.
  
When @NonNull is used in a class field, create a @property setter in Python that checks provided value is not null (None).
  

### Interfaces and Abstract classes

The Java code often uses an interface+abstract class pattern: typically there is an interface I and an abstract class AI that implements I, with the purpose to have developers extend AI for actual implementations of I; this also to allow Java classes to extend multiple interfaces whilst providing some boiler plate code in abstract classes.

An example of this pattern are the Tool and AbstractTool:

```java
public interface Tool {
	String getId();
	String getDescription();
	boolean isClosed();	
	void init(Agent agent);
	...other interface methods
}

public abstract class AbstractTool implements Tool {

	@Getter
	private final String id;

	@Getter
	private String description = "";

	@Getter
	@Setter(AccessLevel.PROTECTED)
	private boolean closed = false;
	
	@Override
	public void init(@NonNull Agent agent) {
		...implements init()
	}
}

public class MyTool extends AbstractTool implements Closeable {
	...
}
```

In Python this must be translated with a similar pattern, as shown below. Notice that the Tool interface defines getters as interface methods, but we have a 6rule to translate those into publicly accessible fields in Python

```python
from abc import ABC, abstractmethod
from typing import Protocol


class Tool(ABC):
    """Python equivalent of a Java interface, note getters are replaced with publicly accessible fields."""
    id: str
    description: str

    @abstractmethod
    def init(self, agent: "Agent") -> None: ...
    # ...other interface methods.


class AbstractTool(Tool):
    """Python equivalent of the Java abstract class"""
    def __init__(self, id_: str, description: str) -> None:
        self.id: str = id_
        self.description: str = description
        self.closed: bool = False

    def init(self, agent: "Agent") -> None:
        # ...implements init()


class MyTool(AbstractTool, Closeable):

    def close(self) -> None:
        # ...from Closeable
```

### JSON schema and serialisation

The Java class `JsonShema` is only meant to provide static methods to:

  1. Obtain a JSON schema from a class.
  2. Serialise an instance of a class into JSON.
  3. De-serialise the JSON representation of a class.
  
For 1. the class relies on Jackson annotations; an example is provided below.

Given this class annotated with Jackson annotations:

```java
@JsonSchemaDescription("This is a class describing parameters for GetCurrentWeatherTool")
public static class Parameters {

	private enum TemperatureUnits {
		CELSIUS, FARENHEIT
	};

	@JsonProperty(required = true)
	@JsonPropertyDescription("The city and state, e.g. San Francisco, CA.")
	public String location;

	@JsonPropertyDescription("Temperature unit (CELSIUS or FARENHEIT), defaults to CELSIUS")
	public TemperatureUnits unit;
}
```

Calling `JsonSchema.getJsonSchema(Parameters.class)` will return the following:

```
{"$schema":"http://json-schema.org/draft-04/schema#","title":"Parameters","type":"object","additionalProperties":false,"description":"This is a class describing parameters for GetCurrentWeatherTool","properties":{"location":{"type":"string","description":"The city and state, e.g. San Francisco, CA."},"unit":{"type":"string","enum":["CELSIUS","FARENHEIT"],"description":"Temperature unit (CELSIUS or FARENHEIT), defaults to CELSIUS"}},"required":["location"]}
```

When translating JsonSchema into Python, it is expected that pydantic and its annotations are used to generate an exact JSON schema like the above.

When translating Java classes into Python strictly ensure Jackson annotations are replaced with corresponding Pydantic ones.

<java>

## AbstractTool.java

package core;

import java.util.Map;

import com.fasterxml.jackson.core.JsonProcessingException;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

/**
 * This is an abstract class that implementations of {@link Tool}s can extend.
 * It mostly provides methods to read and cast arguments parameters into the right type.
 * 
 * @author Massimiliano "Maxi" Zattera
 */
public abstract class AbstractTool implements Tool {

	@Getter
	private final String id;

	@Getter
	private String description = "";

	/**
	 * JSON schema describing parameters for this tool.
	 */
	@Getter
	private final String jsonParameters;

	@Getter
	private Agent agent;

	@Getter
	@Setter(AccessLevel.PROTECTED)
	private boolean closed = false;

	@Override
	public boolean isInitialized() {
		return (agent != null);
	}

	@Override
	public void init(@NonNull Agent agent) {
		if (isInitialized())
			throw new RuntimeException("Tool " + id + " is already initialized");
		if (closed)
			throw new RuntimeException("Tool " + id + " is already closed");
		this.agent = agent;
	}

	protected AbstractTool(@NonNull String id, String description, @NonNull Class<?> c) throws JsonProcessingException {
		this.id = id;
		this.description = description;
		this.jsonParameters = JsonSchema.getJsonSchema(c);
	}

	@Override
	public void close() {
		closed = true;
	}

	//
	// Below there are utility methods to read parameters.
	// When translating these into Python you need to check whether parameters are of desired type OR
	// they are string values that can be parsed into instances of given type.
	//
	// ////////////////////////////////////////////////////////////////////////////////////////////

	protected static boolean getBoolean(String name, Map<String, ? extends Object> args) {
		if (args.containsKey(name))
			return getBoolean(name, args.get(name));
		throw new IllegalArgumentException("Missing required parameter \"" + name + "\".");
	}

	protected static boolean getBoolean(String name, Map<String, ? extends Object> args, boolean def) {
		if (!args.containsKey(name))
			return def;
		return getBoolean(name, args.get(name));
	}

	private static boolean getBoolean(String name, Object value) {
		String s = value.toString();
		if ("true".equals(s.trim().toLowerCase()))
			return true;
		if ("false".equals(s.trim().toLowerCase()))
			return false;

		throw new IllegalArgumentException(
				"Parameter \"" + name + "\" is expected to be a boolean value but it is not.");
	}

	protected static long getLong(String name, Map<String, ? extends Object> args) {
		if (args.containsKey(name))
			return getLong(name, args.get(name));
		throw new IllegalArgumentException("Missing required parameter \"" + name + "\".");
	}

	protected static long getLong(String name, Map<String, ? extends Object> args, long def) {
		if (!args.containsKey(name))
			return def;
		return getLong(name, args.get(name));
	}

	private static long getLong(String name, Object value) {
		try {
			return Long.parseLong(value.toString());
		} catch (Exception e) {
			throw new IllegalArgumentException(
					"Parameter \"" + name + "\" is expected to be a integer value but it is not.");
		}
	}

	protected static double getDouble(String name, Map<String, ? extends Object> args) {
		if (args.containsKey(name))
			return getDouble(name, args.get(name));
		throw new IllegalArgumentException("Missing required parameter \"" + name + "\".");
	}

	protected static double getDouble(String name, Map<String, ? extends Object> args, double def) {
		if (!args.containsKey(name))
			return def;
		return getDouble(name, args.get(name));
	}

	protected static double getDouble(String name, Object value) {
		try {
			return Double.parseDouble(value.toString());
		} catch (Exception e) {
			throw new IllegalArgumentException(
					"Parameter \"" + name + "\" is expected to be a decimal number but it is not.");
		}
	}

	protected static String getString(String name, Map<String, ? extends Object> args) {
		Object result = args.get(name);
		if (result == null)
			return null;
		return result.toString();
	}

	protected static String getString(String name, Map<String, ? extends Object> args, String def) {
		if (!args.containsKey(name))
			return def;
		return getString(name, args);
	}
}

## Agent.java

package core;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.openai.client.OpenAIClient;
import com.openai.client.okhttp.OpenAIOkHttpClient;
import com.openai.core.JsonMissing;
import com.openai.models.FunctionDefinition;
import com.openai.models.FunctionParameters;
import com.openai.models.ResponseFormatJsonSchema;
import com.openai.models.ResponseFormatJsonSchema.JsonSchema.Schema;
import com.openai.models.chat.completions.ChatCompletionAssistantMessageParam;
import com.openai.models.chat.completions.ChatCompletionAssistantMessageParam.Builder;
import com.openai.models.chat.completions.ChatCompletionCreateParams;
import com.openai.models.chat.completions.ChatCompletionCreateParams.ResponseFormat;
import com.openai.models.chat.completions.ChatCompletionDeveloperMessageParam;
import com.openai.models.chat.completions.ChatCompletionMessage;
import com.openai.models.chat.completions.ChatCompletionMessageParam;
import com.openai.models.chat.completions.ChatCompletionMessageToolCall;
import com.openai.models.chat.completions.ChatCompletionMessageToolCall.Function;
import com.openai.models.chat.completions.ChatCompletionTool;
import com.openai.models.chat.completions.ChatCompletionToolMessageParam;
import com.openai.models.chat.completions.ChatCompletionUserMessageParam;

import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

/**
 * This class implements an Agent that uses OpenAI models via the Chat
 * Completions API. This class is implemented using the OpenAI Java SDK.
 * 
 * @author Massimiliano "Maxi" Zattera
 */
public class Agent {

	private final static Logger LOG = LoggerFactory.getLogger(Agent.class);

	public static final String DEFAULT_MODEL = "gpt-4.1";

	protected Agent() {
		this("OpenAIChatCompletionService", "Test agent", new ArrayList<>());
	}

	protected Agent(@NonNull String id, @NonNull String description, @NonNull List<? extends Tool> tools) {
		this.client = OpenAIOkHttpClient.fromEnv();
		this.id = id;
		this.description = description;
		for (Tool t : tools) {
			t.init(this);
			toolMap.put(t.getId(), t);
		}
		this.model = DEFAULT_MODEL;
		this.temperature = 0.0d;
	}

	/**
	 * This class uses an OpenAIClient to call the OpenAI API. In python you do not
	 * need a client; you can omit this field and use openai intead.
	 * 
	 * E.g. instead of:
	 * 
	 * client.chat().completions().create(req);
	 * 
	 * In Python use:
	 * 
	 * import openai
	 * 
	 * openai.ChatCompletion.create(**req)
	 */
	protected final OpenAIClient client;

	/**
	 * Unique agent ID.
	 */
	@Getter
	private final String id;

	/**
	 * A verbose description of the agent, describing its capabilities.
	 */
	@Getter
	@Setter
	private String description;

	/**
	 * The name of the LLM model used by this agent (e.g. "gpt-4").
	 */
	@Getter
	@Setter
	private String model;

	/**
	 * Personality (system prompt) for the agent.
	 */
	@Getter
	@Setter
	private String personality;

	/**
	 * Messages exchanged so far in current conversation with the agent.
	 */
	@Getter
	private final List<ChatMessage> history = new ArrayList<>();

	/**
	 * The temperature of the sampling operation for the underlying LLM.
	 */
	@Getter
	@Setter
	private Double temperature = 0d;

	/**
	 * Starts a new chat, clearing current conversation.
	 */
	public void clearConversation() {
		history.clear();
	}

	/**
	 * Maximum number of messages to keep in chat history.
	 */
	@Getter
	@Setter
	private int maxHistoryLength = Integer.MAX_VALUE;

	/**
	 * Maximum number of history messages to send to LLM during a conversation.
	 * 
	 * Notice this does NOT limit length of conversation history (see
	 * {@link #getMaxHistoryLength}).
	 */
	@Getter
	@Setter
	private int maxConversationSteps = Integer.MAX_VALUE;

	/**
	 * Output format for the model, as JSON schema.
	 */
	@Getter
	private String responseFormat;

	/**
	 * This method allows to specify an output format for the model. This is used to
	 * create structured outputs with model supporting it so that, for example, the
	 * model returns its responses in a pre-defined JSON format.
	 * 
	 * @param schema A class which schema will be used to define the output format.
	 */
	public void setResponseFormat(Class<?> schema) {
		responseFormat = JsonSchema.getJsonSchema(schema);
	}

	/**
	 * Available and already initialized tools that agent can use. Maps each tool ID
	 * into corresponding tool instance.
	 */
	protected Map<String, Tool> toolMap = new HashMap<>();

	/**
	 * Continues current chat, with the provided message.
	 * 
	 * The exchange is added to the conversation history.
	 */
	public ChatCompletion chat(String msg) {
		return chat(new ChatMessage(ChatMessage.Author.USER, msg));

	}

	/**
	 * Continues current chat, with the provided message.
	 * 
	 * The exchange is added to the conversation history.
	 */
	public ChatCompletion chat(ChatMessage msg) {
		return chat(List.of(msg));
	}

	/**
	 * Continues current chat, with the provided messages.
	 * 
	 * The exchange is added to the conversation history.
	 */
	public ChatCompletion chat(List<ChatMessage> msg) {

		// Add messages to conversation and trims it; this also adds personality
		List<ChatMessage> conversation = new ArrayList<>(getHistory());
		conversation.addAll(msg);
		trimConversation(conversation);

		// Create response
		ChatCompletion result = chatCompletion(conversation);

		// Add messages and response to history
		getHistory().addAll(msg);
		getHistory().add(result.getMessage());

		// Make sure history is of desired length
		if (getHistory().size() > getMaxHistoryLength()) {
			getHistory().subList(0, getHistory().size() - getMaxHistoryLength()).clear();
		}

		return result;
	}

	/**
	 * Completes text outside a conversation (executes given prompt ignoring and
	 * without affecting conversation history).
	 * 
	 * Notice this does not consider or affects chat history but bot personality is
	 * used, if provided.
	 */
	public ChatCompletion complete(String prompt) {
		return complete(new ChatMessage(ChatMessage.Author.USER, prompt));
	}

	/**
	 * Completes text outside a conversation (executes given prompt ignoring and
	 * without affecting conversation history).
	 * 
	 * Notice this does not consider or affects chat history but bot personality is
	 * used, if provided.
	 */
	public ChatCompletion complete(ChatMessage prompt) {

		List<ChatMessage> conversation = List.of(prompt);
		trimConversation(conversation);

		return chatCompletion(conversation);
	}

	/**
	 * Trims given list of messages (typically a conversation history), so it fits
	 * the limits set in this instance (that is, maximum conversation steps).
	 * 
	 * Notice the personality (system prompt) is always and automatically added on
	 * top of the trimmed list (if set).
	 * 
	 * @throws IllegalArgumentException if no message can be added because of
	 *                                  context size limitations.
	 */
	private void trimConversation(List<ChatMessage> messages) {

		// Remove tool call results left on top without corresponding calls, or this
		// will cause HTTP 400 error for tools
		int firstNonToolIndex = 0;
		for (ChatMessage m : messages) {
			if (m.hasToolCallResults()) {
				firstNonToolIndex++;
			} else {
				break;
			}
		}
		if (firstNonToolIndex > 0) {
			messages.subList(0, firstNonToolIndex).clear();
		}

		// Trims down the list of messages accordingly to given limits.
		if (messages.size() > getMaxConversationSteps())
			messages.subList(0, messages.size() - getMaxConversationSteps()).clear();

		if (messages.size() == 0)
			throw new IllegalArgumentException("No messages left in conversation");

		if (getPersonality() != null)
			// must add a system message on top with personality
			messages.add(0, new ChatMessage(ChatMessage.Author.DEVELOPER, getPersonality()));
	}

	/**
	 * This method sends given list of messages to the LLM and creates corresponding
	 * chat response, which is returned.
	 */
	@SuppressWarnings("unchecked")
	private ChatCompletion chatCompletion(List<ChatMessage> messages) {

		// The method starts by building required ChatCompletionCreateParams instance to
		// call the OpenAI chat API.
		// When translating this into Python you should be a request req that is then
		// sent to openai.ChatCompletion.create(**req)

		// Translate messages into format suitable to be used with OpenAI API
		// Here each ChatMessage is translated into the corresponding
		// ChatCompletionMessageParam.
		List<ChatCompletionMessageParam> openAiMessages = new ArrayList<>();
		for (ChatMessage m : messages)
			openAiMessages.addAll(fromChatMessage(m));

		// ThHere we use a Builder to build ChatCompletionCreateParams step by step
		// Notice that here we set the model, the messages and the temperature
		// With OpenAI Java SDK, messages must be a list of ChatCompletionMessageParam
		// but in Python you might build them differently as part of req; check what
		// fromChatMessage() does
		ChatCompletionCreateParams.Builder b = ChatCompletionCreateParams.builder() //
				.model(getModel()) //
				.messages(openAiMessages) //
				.temperature(getTemperature());

		// Only if response format was set, provide it; check what
		// createResponseFormat() does
		if (getResponseFormat() == null)
			b.responseFormat(JsonMissing.of());
		else
			b.responseFormat(createResponseFormat());

		// If there is any tool, provide them in req; check what createToolDefinitions()
		// does
		if (toolMap.size() == 0)
			b.tools(JsonMissing.of());
		else
			b.tools(createToolDefinitions());
		ChatCompletionCreateParams req = b.build();

		LOG.info(req.toString());

		// Calls OpenAI Chat Completion API and returns result
		com.openai.models.chat.completions.ChatCompletion resp = client.chat().completions().create(req);
		com.openai.models.chat.completions.ChatCompletion.Choice choice = resp.choices().get(0);
		return new ChatCompletion(fromOpenAiApi(choice.finishReason()), fromOpenAiMessage(choice.message()));
	}

	/**
	 * Translates Java OpenAI SDK finish reason into one we can use.
	 */
	private static ChatCompletion.FinishReason fromOpenAiApi(
			com.openai.models.chat.completions.ChatCompletion.Choice.FinishReason finishReason) {
		switch (finishReason.value()) {
		case STOP:
		case TOOL_CALLS:
		case FUNCTION_CALL:
			return ChatCompletion.FinishReason.COMPLETED;
		case LENGTH:
			return ChatCompletion.FinishReason.TRUNCATED;
		case CONTENT_FILTER:
			return ChatCompletion.FinishReason.INAPPROPRIATE;
		default:
			throw new IllegalArgumentException("Unrecognized finish reason: " + finishReason);
		}
	}

	/**
	 * Turns an ChatCompletionMessageParam returned by API into a ChatMessage. This
	 * is required because we want to return ChatMessage objects and store them as
	 * such in the history.
	 */
	private ChatMessage fromOpenAiMessage(ChatCompletionMessage msg) {

		if (msg.toolCalls().isPresent()) {

			// The model returned a set of tool calls, transparently translate that into a
			// message with a multiple parts each being a ToolCall
			List<ToolCall> calls = new ArrayList<>();
			for (ChatCompletionMessageToolCall call : msg.toolCalls().get()) {
				ToolCall toolCall;
				try {
					toolCall = ToolCall.builder() //
							.id(call.id()) //
							.tool(toolMap.get(call.function().name())) //
							.arguments(call.function().arguments()) //
							.build();
				} catch (JsonProcessingException e) {
					throw new IllegalArgumentException(e);
				}
				calls.add(toolCall);
			}

			// Nothing else to return in this case
			return new ChatMessage(ChatMessage.Author.BOT, calls);
		}

		List<MessagePart> parts = new ArrayList<>();
		if (msg.content().isPresent()) {
			// Normal (text) message was returned, just add it as TextPart
			parts.add(new TextPart(msg.content().get()));
		}
		if (msg.refusal().isPresent()) {
			// OpenAI returned a refusal; translate it into a text message and attach it as
			// TextPart
			parts.add(new TextPart("**The model generated a refusal**\n\n" + msg.refusal().get()));
		}

		// Return a message with all the parts we found
		return new ChatMessage(ChatMessage.Author.BOT, parts);
	}

	/**
	 * This converts a generic ChatMessaege provided by user into an
	 * ChatCompletionMessageParam that is used for the OpenAi API. This is needed
	 * because we want to deal with ChatMessage when talking to the agent.
	 */
	private List<ChatCompletionMessageParam> fromChatMessage(ChatMessage msg) {

		if (msg.hasToolCalls()) {

			// The message contains tool calls; we translate them into a
			// ChatCompletionAssistantMessageParam which will contain all these calls
			Builder b = ChatCompletionAssistantMessageParam.builder();
			for (ToolCall c : msg.getToolCalls()) {
				try {
					b.addToolCall(ChatCompletionMessageToolCall.builder() //
							.id(c.getId()).function(Function.builder() //
									.name(c.getTool().getId()) //
									.arguments(JsonSchema.serialize(c.getArguments())) //
									.build()) //
							.build());
				} catch (JsonProcessingException e) {
					// Rethrows as runtime exception; in Python you do not need to know since you do
					// not need to declare exceptions in methods
					throw new RuntimeException(e);
				}
			}

			// There is nothing else to return since in this case the message will only have
			// calls.
			return List.of(ChatCompletionMessageParam.ofAssistant(b.build())); //
		}

		if (msg.hasToolCallResults()) {

			// The message contains some call results that we translate into corresponding
			// ChatCompletionMessageParam
			List<ChatCompletionMessageParam> result = new ArrayList<>();
			List<ToolCallResult> results = msg.getToolCallResults();
			for (ToolCallResult r : results) {
				result.add(ChatCompletionMessageParam.ofTool( //
						ChatCompletionToolMessageParam.builder() //
								.content(r.getResult().toString()) //
								.toolCallId(r.getToolCallId()).build() //
				));
			}

			// There is nothing else to return since in this case the message will only have
			// call results.
			return result;
		}

		// In all other cases, we expect a simple text message
		if (msg.isText()) {
			if (msg.getParts().size() != 1)
				throw new IllegalArgumentException(
						"Message can be only be simple text, a tool call, or tool call results");

			// Return corresponding ChatCompletionMessageParam
			switch (msg.getAuthor()) {
			case USER:
				return List.of(ChatCompletionMessageParam.ofUser( //
						ChatCompletionUserMessageParam.builder().content(msg.getTextContent()).build() //
				));
			case DEVELOPER:
				return List.of(ChatCompletionMessageParam.ofDeveloper( //
						ChatCompletionDeveloperMessageParam.builder().content(msg.getTextContent()).build() //
				));
			case BOT:
				return List.of(ChatCompletionMessageParam.ofAssistant( //
						ChatCompletionAssistantMessageParam.builder().content(msg.getTextContent()).build() //
				));
			default:
				throw new IllegalArgumentException("Message author not supported: " + msg.getAuthor());
			}
		}

		throw new IllegalArgumentException("Message can be only be simple text, a tool call, or tool call results");
	}

	/**
	 * @return A ResponseFormat that can be used to create a
	 *         ChatCompletionCreateParams to call OpenAI Chat Completion API.
	 */
	private ChatCompletionCreateParams.ResponseFormat createResponseFormat() {

		try {
			return ResponseFormat.ofJsonSchema( //
					ResponseFormatJsonSchema.builder() //
							.jsonSchema( //
									ResponseFormatJsonSchema.JsonSchema.builder() //
											.name("Anonymous") //
											.description("No Description") //
											.schema(JsonSchema.deserialize(getResponseFormat(), Schema.class)) //
											.build() //
							).build());
		} catch (JsonProcessingException e) {
			// Rethrows as runtime exception; in Python you do not need to know since you do
			// not need to declare exceptions in methods
			throw new RuntimeException(e);
		}
	}

	/**
	 * @return A List<ChatCompletionTool> that can be used to create a
	 *         ChatCompletionCreateParams to call OpenAI Chat Completion API. The
	 *         list will contain definitions for all the tools this agent can use.
	 */
	private List<ChatCompletionTool> createToolDefinitions() {

		List<Tool> tools = new ArrayList<>(toolMap.values());
		List<ChatCompletionTool> tls = new ArrayList<>(tools.size());
		for (Tool t : tools) {
			ChatCompletionTool f;
			try {
				f = ChatCompletionTool.builder() //
						.function( //
								FunctionDefinition.builder() //
										.name(t.getId()) //
										.description(t.getDescription()) //
										.strict(false) //
										.parameters(
												JsonSchema.deserialize(t.getJsonParameters(), FunctionParameters.class))
										.build() //
						).build();
			} catch (JsonProcessingException e) {
				// Rethrows as runtime exception; in Python you do not need to know since you do
				// not need to declare exceptions in methods
				throw new RuntimeException(e);
			}
			tls.add(f);
		}

		return tls;
	}

	/**
	 * Closes the agent freeing up resources.
	 */
	public void close() {
		for (Tool t : toolMap.values()) {
			try {
				t.close();
			} catch (Exception e) {
			}
		}

		try {
			client.close();
		} catch (Exception e) {
		}
	}

	public static class Format {
		@JsonProperty(required = true)
		@JsonPropertyDescription("Your output message")
		public String out;
	}

	public static void main(String[] args) {
		Agent bot = null;
		try {
			bot = new Agent();
			bot.setPersonality(
					"Always output messages as described by this schema: " + JsonSchema.getJsonSchema(Format.class));
			bot.setResponseFormat(Format.class);

			System.out.println(bot.chat("Ciao!").getText());
		} catch (Exception e) {
			e.printStackTrace(System.err);
		} finally {
			if (bot != null)
				try {
					bot.close();
				} catch (Exception e) {
				}
		}
	}
}

## ChatCompletion.java

package core;

import com.fasterxml.jackson.core.JsonProcessingException;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.SuperBuilder;

/**
 * This class encapsulates the response from a LLM (as a {@link ChatMessage}).
 * 
 * In addition, this also contains a reason why the response terminated.
 * 
 * @author Massimiliano "Maxi" Zattera.
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@RequiredArgsConstructor
@SuperBuilder
@Getter
@Setter
@ToString
public class ChatCompletion {

	/**
	 * This enumeration describes possible ways in which a language model completed
	 * its output.
	 * 
	 * @author Massimiliano "Maxi" Zattera.
	 */
	public enum FinishReason {

		/**
		 * Text generation is not yet completed, model might be returning a partial
		 * result (e.g. to allow streaming).
		 */
		IN_PROGRESS,

		/**
		 * Text generation has successfully terminated and the text is complete.
		 */
		COMPLETED,

		/**
		 * Text generation is finished, but the text was truncated, probably for
		 * limitations in model output length.
		 */
		TRUNCATED,

		/**
		 * Text content was in part or completely omitted due to content filters (e.g.
		 * profanity filter)
		 */
		INAPPROPRIATE,

		/** All finish reasons that do not fit in any other value */
		OTHER;
	}

	@NonNull
	private FinishReason finishReason;

	@NonNull
	private ChatMessage message;

	/**
	 * 
	 * @return A string representation of the returned message..
	 */
	public String getText() {
		return message.getTextContent();
	}

	/**
	 * 
	 * @return The content of this message as an instance of given class. This
	 *         assumes {@link #getText()} will return a properly formatted JSON
	 *         representation of the object.
	 * 
	 * @throws JsonProcessingException If an error occurs while parsing the message
	 *                                 content.
	 */
	public <T> T getObject(Class<T> c) throws JsonProcessingException {
		return JsonSchema.deserialize(getText(), c);
	}
}

## ChatMessage.java

package core;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.core.JsonProcessingException;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;

/**
 * This is a message exchanged with  an {@link Agent}.
 * 
 * Messages are formed by a list of {@link MessagePart}s; each part can provide
 * different contents (e.g. some text, a tool invocation
 * and its results, etc.).
 * 
 * @author Massmiliano "Maxi" Zattera.
 *
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@RequiredArgsConstructor
@Getter
@Setter
@ToString
public class ChatMessage {

	/**
	 * The author (originator) of the message.
	 */
	public enum Author {

		/** Marks messages coming from the user */
		USER("user"),

		/** Marks messages coming from the bot/agent/assistant */
		BOT("bot"),

		/**
		 * Marks messages coming from the developer. For some models, this is used to
		 * provide instructions to the model
		 */
		DEVELOPER("developer");

		private final String label;

		private Author(String label) {
			this.label = label;
		}

		@Override
		@JsonValue
		public String toString() { // Notice we rely on labels not to change
			return label;
		}
	}

	@NonNull
	private Author author;

	@NonNull
	private List<MessagePart> parts = new ArrayList<>();

	public void setParts(List<? extends MessagePart> parts) {
		this.parts.addAll(parts);
	}

	public ChatMessage(String content) {
		this(Author.USER, content);
	}

	public ChatMessage(@NonNull MessagePart part) {
		this(Author.USER, part);
	}

	public ChatMessage(@NonNull List<? extends MessagePart> parts) {
		this(Author.USER, parts);
	}

	public ChatMessage(@NonNull Author author, String content) {
		this.author = author;
		if (content != null)
			parts.add(new TextPart(content));
	}

	public ChatMessage(@NonNull Author author, @NonNull MessagePart part) {
		this.author = author;
		this.parts.add(part);
	}

	public ChatMessage(@NonNull Author author, @NonNull List<? extends MessagePart> parts) {
		this.author = author;
		this.parts.addAll(parts);
	}

	/**
	 * 
	 * @return True if and only if this message is pure text.
	 */
	public boolean isText() {
		for (MessagePart part : parts)
			if (!(part instanceof TextPart))
				return false;
		return true;
	}

	/**
	 * 
	 * @return True if this message contains at least one part which is text.
	 */
	public boolean hasText() {
		for (MessagePart part : parts)
			if (part instanceof TextPart)
				return true;
		return false;
	}

	/**
	 * 
	 * @return A string representation of the content of this message. Notice the
	 *         message could contain parts which are not easily representable as
	 *         text (e.g. a file). See {@link #isText()}.
	 */
	public String getTextContent() {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < parts.size(); ++i) {
			if (i > 0)
				result.append("\n\n");
			result.append(parts.get(i).getContent());
		}
		return result.toString();
	}

	/**
	 * 
	 * @return The content of this message as an instance of given class. This
	 *         assumes {@link #getTextContent()} will return a properly formatted
	 *         JSON representation of the object.
	 * 
	 * @throws JsonProcessingException If an error occurs while parsing the message
	 *                                 content.
	 */
	public <T> T getObjectContent(Class<T> c) throws JsonProcessingException {
		return JsonSchema.deserialize(getTextContent(), c);
	}

	/**
	 * 
	 * @return True if this message contains at least one invocation of a tool.
	 */
	public boolean hasToolCalls() {
		for (MessagePart part : parts)
			if (part instanceof ToolCall)
				return true;
		return false;
	}

	/**
	 * 
	 * @return All tool invocations contained in this message.
	 */
	public List<ToolCall> getToolCalls() {
		return parts.stream() //
				.filter(ToolCall.class::isInstance) //
				.map(ToolCall.class::cast) //
				.collect(Collectors.toList());
	}

	/**
	 * 
	 * @return True if this message contains at least one tool call response.
	 */
	public boolean hasToolCallResults() {
		for (MessagePart part : parts)
			if (part instanceof ToolCallResult)
				return true;
		return false;
	}

	/**
	 * 
	 * @return All tool invocations contained in this message.
	 */
	public List<ToolCallResult> getToolCallResults() {
		return parts.stream() //
				.filter(ToolCallResult.class::isInstance) //
				.map(ToolCallResult.class::cast) //
				.collect(Collectors.toList());
	}
}

## JsonSchema.java

package core;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.kjetland.jackson.jsonSchema.JsonSchemaGenerator;

/**
 * The class provide methods to :
 * 
 * 1. Obtain a JSON schema from a class.
 * 
 * 2. Serialise an instance of a class into JSON.
 * 
 * 3. De-serialise the JSON representation of a class.
 *
 * The class fully supports Jackson annotations when creating a schema fro a
 * class.
 * 
 * @see <a href=
 *      "https://json-schema.org/understanding-json-schema">Understanding JSON
 *      Schema</a>
 * 
 * @author Massimiliano "Maxi" Zattera
 */
public class JsonSchema {

	/** Used for creating JSON schema out of classes */
	private final static JsonSchemaGenerator SCHEMA_GENERATOR = new JsonSchemaGenerator(new ObjectMapper());

	/**
	 * Mapper provided for JSON serialisation via Jackson, if needed. Use this to
	 * deserialized objects that have been created through some schema.
	 */
	private static final ObjectMapper JSON_MAPPER;
	static {
		JSON_MAPPER = new ObjectMapper();
		JSON_MAPPER.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		JSON_MAPPER.setSerializationInclusion(JsonInclude.Include.NON_NULL);
	}

	// The below method uses JsonSchemaGenerator and Jacksoon annotations to create
	// a JSON schema fro the class. Use pydantic and its annotations to achieve same
	// result.
	
	/**
	 * @return JSON schema for the class c.
	 * @throws JsonProcessingException
	 */
	public static <T> String getJsonSchema(Class<T> c) {
		try {
			return JSON_MAPPER.writeValueAsString(SCHEMA_GENERATOR.generateJsonSchema(c));
		} catch (JsonProcessingException e) {
			return null; // Should never happen
		}
	}

	// Below Java methods can easily be translated in Python by using pydantic:
	//
	// from typing import Type, TypeVar
	// from pydantic import BaseModel
	//
	// T = TypeVar("T", bound=BaseModel)
	//
	//
	// # ---------- generic helpers ----------
	// def serialize(obj: BaseModel) -> str:
	// """Return *obj* as a JSON string, omitting fields whose value is None."""
	// return obj.json(exclude_none=True)
	//
	//
	// def deserialize(json_str: str, cls: Type[T]) -> T:
	// """Parse *json_str* into an instance of *cls*, ignoring unknown keys."""
	// return cls.parse_raw(json_str)
	// # -------------------------------------

	/**
	 * @return The Object o serialised as a JSON string.
	 */
	public static <T> String serialize(Object o) throws JsonProcessingException {
		return JSON_MAPPER.writeValueAsString(o);
	}

	/**
	 * @param json An object of type T serialised using JSON.
	 * @return An instance of T, corresponding to the object that is provided as
	 *         JSON object.
	 * @throws JsonProcessingException
	 * @throws JsonMappingException
	 */
	public static <T> T deserialize(String json, Class<T> c) throws JsonProcessingException {
		return JSON_MAPPER.readValue(json, c);
	}

	/**
	 * @param json An object of type T serialised using JSON.
	 * @return An instance of T, corresponding to the object that is provided as
	 *         JSON object.
	 */
	public static <T> T deserialize(String json, TypeReference<T> c) throws JsonProcessingException {
		return JSON_MAPPER.readValue(json, c);
	}

	public static void main(String[] args) {
		System.out.println(JsonSchema.getJsonSchema(FunctionCallExample.GetCurrentWeatherTool.Parameters.class));
	}
}

## MessagePart.java

package core;

/**
 * Marker interface for classes that can be parts of a {@link ChatMessage}.
 * 
 * 
 * @author Massimiliano "Maxi" Zattera.
 */
public interface MessagePart {

	/**
	 * 
	 * @return A string representation of the content of this message part. Notice
	 *         not all parts are easily representable as text (e.g. a file).
	 */
	String getContent();
}


## TextPart.java

package core;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.SuperBuilder;

/**
 * This is a {@link MessagePart} that contains only text.
 * 
 * @author Massimiliano "Maxi" Zattera.
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@RequiredArgsConstructor
@SuperBuilder
@ToString
public class TextPart implements MessagePart {

	@Getter
	@Setter
	private @NonNull String content;
}


## Tool.java

package core;

import lombok.NonNull;

/**
 * This is a tool that an {@link Agent} can invoke to perform a task.
 * Tool life cycle involves tool been initialized once before it is called and closed when it is no longer needed.
 * 
 * @author Massimiliano "Maxi" Zattera.
 *
 */
public interface Tool {

	/**
	 * Unique identifier for the tool; this is used as tool ID in API calls normally.
	 * 
	 * @return
	 */
	String getId();

	/**
	 * 
	 * @return A verbose description of what the tool does does, so that the agent
	 *         knows when to call it.
	 */
	String getDescription();

	/**
	 * 
	 * @return JSON Schema describing the parameters for the tool.
	 */
	String getJsonParameters();

	/**
	 * 
	 * @return True if the tool was already initialized.
	 */
	boolean isInitialized();

	/**
	 * 
	 * @return True if the tool was already closed.
	 */
	boolean isClosed();

	/**
	 * This must be called by the agent once and only once before any invocation to
	 * this tool.
	 * 
	 * @param agent The agent that is using this tool.
	 */
	void init(@NonNull Agent agent);

	/**
	 * Invokes (executes) the tool. This can be called several times.
	 * 
	 * @param call The call to the tool, created by the calling agent.
	 * 
	 * @return The result of calling the tool.
	 * 
	 * @param RuntimeException if the tool was not yet initialized.
	 */
	ToolCallResult invoke(@NonNull ToolCall call) throws Exception;
	
	/**
	 * Closes the tool when it is no longer needed.
	 */
    void close() throws Exception;
}

## ToolCall.java

package core;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;

/**
 * {@link Agent}s can invoke tools. This interface represents a single tool
 * invocation, as part of a message.
 * 
 * @author Massimiliano "Maxi" Zattera
 *
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@RequiredArgsConstructor
@Getter
@Setter
@ToString
public class ToolCall implements MessagePart {

	/**
	 * Builder
	 * 
	 * @author Luna
	 */
	public static final class Builder {
		private String id;
		private Tool tool;
		private Map<String, Object> arguments = new HashMap<>();

		public Builder id(@NonNull String id) {
			this.id = id;
			return this;
		}

		public Builder tool(@NonNull Tool tool) {
			this.tool = tool;
			return this;
		}

		/** Accepts any map whose values extend Object. */
		public Builder arguments(@NonNull Map<String, ? extends Object> args) {
			this.arguments = new HashMap<>(args);
			return this;
		}

		/**
		 * Parse a JSON string into the arguments map.
		 * 
		 * @throws JsonProcessingException
		 */
		public Builder arguments(@NonNull String json) throws JsonProcessingException {

			this.arguments = JsonSchema.deserialize(json, new TypeReference<Map<String, Object>>() {
			});
			return this;
		}

		public ToolCall build() {
			ToolCall tc = new ToolCall();
			tc.setId(Objects.requireNonNull(id, "id must not be null"));
			tc.setTool(Objects.requireNonNull(tool, "tool must not be null"));
			tc.setArguments(arguments);
			return tc;
		}
	}

	public static Builder builder() {
		return new Builder();
	}
	
	/**
	 * Unique ID for this tool call.
	 */
	@NonNull
	private String id;

	/**
	 * The tool being called. Notice it is not always guaranteed this to be set
	 * correctly, as some services might not be able to retrieve the proper Tool
	 * instance; this depends on the service generating the call. If this field is
	 * null, developers need to map this call to the proper tool externally from the
	 * service.
	 */
	private Tool tool;

	/**
	 * Arguments to use in the call, as name/value pairs.
	 */
	@NonNull
	private Map<String, Object> arguments = new HashMap<>();

	@Override
	public String getContent() {
		return toString();
	}

	/**
	 * Executes this call. Notice this will work only if {{@link #getTool()} returns
	 * a valid tool.
	 * 
	 * @return Result of invoking the tool.
	 * @throws Exception If an error occurs while executing the call.
	 */
	public ToolCallResult execute() throws Exception {
		return getTool().invoke(this);
	}
}

## ToolCallResult.java

package core;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.SuperBuilder;

/**
 * This holds the results of a {@link ToolCall}. It is used to pass results from
 * tool execution back to the calling agent.
 * 
 * @author Massimiliano "Maxi" Zattera.
 *
 */
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@RequiredArgsConstructor
@SuperBuilder
@Getter
@Setter
@ToString
public class ToolCallResult implements MessagePart {

	/** Unique ID for corresponding tool invocation. */
	@NonNull
	private String toolCallId;

	/** Unique ID of the tool being called. */
	// TODO Needed?
	@NonNull
	private String toolId;

	/** Result of calling the tool. */
	private String result;

	/** True if the result is an error. */
	@Builder.Default
	private boolean isError = false;

	public ToolCallResult(@NonNull ToolCall call, String result) {
		toolCallId = call.getId();
		toolId = call.getTool().getId();
		this.result = result;
	}

	public ToolCallResult(String toolCallId, String toolId, String result) {
		this.toolCallId = toolCallId;
		this.toolId = toolId;
		this.result = result;
	}
	
	public ToolCallResult(ToolCall call, Exception e) {
		this(call, "Error: " + e.getMessage());
		isError = true;
	}

	@Override
	public String getContent() {
		return ("ToolCallResult(" + (isError ? "*ERROR* " : "") + (result == null ? "" : result.toString()) + ")");
	}

}

## CriticModule.java

package com.infosys.small.react;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.infosys.small.core.Agent;
import com.infosys.small.core.JsonSchema;
import com.infosys.small.core.Tool;
import com.infosys.small.react.ReactAgent.Step;
import com.infosys.small.react.ReactAgent.ToolCallStep;

import lombok.Getter;
import lombok.NonNull;

/**
 * This agent is a critic component, part of a {@link ReactAgent}; its task is
 * to review the performances of the executor component and provide suggestions
 * for it to correct its behavior.
 */
class CriticModule extends Agent {

	private final static Logger LOG = LoggerFactory.getLogger(CriticModule.class);

	@Getter
	private final @NonNull ReactAgent agent;

	// We keep them here because we do not want the reviewer to actually call any
	// tool.
	private final @NonNull List<Tool> tools;

	public static final String PROMPT_TEMPLATE = "# Identity\n\n" //
			+ "You are a reviewer agent; your task is to monitor how an executor agent tries to execute user's commands and provide suggestion to improve execution.\n" //
			+ "The specific user's command the executor is trying to execute is provided in the below <user_command> tag.\n" //
			+ "\n<user_command>\n{{command}}\n</user_command>\n\n" //
			+ "You will be provided by the user with a potentially empty list of execution steps, in <steps> tag, that have been already performed by the executor in its attempt to execute the user's command. The format of these steps is provided as a JSON schema in <step_format> tag below. In these steps, the executor agent is identified with actor==\"{{executor_id}}\".\n"
			+ "\n<step_format>\n" + JsonSchema.getJsonSchema(ToolCallStep.class) + "\n</step_format>\n\n" //
			+ "\n# Additional Context and Information\n\n" //
			+ "  * In order to execute the command, the executor agent has the tools described in the below <tools> tag at its disposal:\n\n"
			+ "<tools>\n{{tools}}\n</tools>\n\n" //
			+ "{{context}}\n";

	public static final String REVIEW_TOOL_CALL_TEMPLATE = PROMPT_TEMPLATE //
			+ "\n# Instructions\n\n" //
			+ "  * If the steps contain evidence that the executor entered a loop calling same tool repeatedly with same parameters, provide a suggestion to strictly call another tool to execute next step.\n"
			+ "  * If and only if last execution step contains a tool call resulting in an error, inspect the tool definition and check for any missing or unsupported parameter in last call; try to understand if missing parameters values are already present in some execution step \"observation\" field. Suggest to the executor to repeat the call, listing the values you find for missed parameters and flagging the unsupported parameters.\n"
			+ "  * **IMPORTANTLY**, in all other case, or if you do not have any relevant suggestion about how to change the executor behavior, just output \"CONTINUE\"."
			+ "  * **IMPORTANTLY** your output is either a suggestion or \"CONTINUE\", do not add any comment if you emit \"CONTINUE\" and do not use \"CONTINUE\" if you have a suggestion.";

	public static final String REVIEW_CONCLUSIONS_TEMPLATE = PROMPT_TEMPLATE //
			+ "\n# Instructions\n\n" //
			+ "  * If and only if last execution step has status=\"ERROR\", it means the executor is aborting execution because it encountered an error it cannot resolve. In this case, examine carefully the execution steps, try to determine what went wrong; if you are able to identify a possible error source and a remediation approach, output a suggestion detailing how the error can be avoided. For example, if the executor is trying to use the wrong tool to perform a task, suggest the proper tool to use.\n"
			+ "  * If and only if last execution step has status=\"COMPLETED\", check it carefully for indication in \"observation\" or \"thought\" fields that the executor has some more steps to perform to complete the user's command. "
			+ "For example, executor might mention it needs to proceed with next steps, or list tasks it still needs to perform. If this is the case, output a suggestion to proceed with execution of these steps.\n"
			+ "  * **IMPORTANTLY**, in all other cases, or if you do not have any relevant suggestion about how to change the executor behavior, just output \"CONTINUE\"."
			+ "  * The only evidence that the executor called a tool or performed a specific task is in the \"action\" field of any step; " //
			+ "do not trust the executor when it says in \"though\" or \"observation\" that an action has been performed, unless that step also contains an \"action\" field mentioning a relevant tool."
			+ "  * **IMPORTANTLY** your output is either a suggestion or \"CONTINUE\", do not add any comment if you emit \"CONTINUE\".\n"
			+ "\n# Examples\n\n" //
			+ "Input:\n\n" //
			+ "<steps>[...<several steps before last one>\n" //
			+ "{\n" //
			+ "  \"status\" : \"COMPLETED\",\n" //
			+ "  \"actor\" : <Executor ID here>,\n" //
			+ "  \"thought\" : \"The next required step is to send an email to the requester with required details. All other process steps have been completed, so I will now send the email and complete execution.\",\n" //
			+ "  \"observation\" : \"Email sent to requester with required details. All required steps in the process have been performed.\"\n" //
			+ "}]\n" //
			+ "</steps>\n" //
			+ "\nCorrect Output:\n\n" //
			+ "There is no evidence you sent the email as needed, no action was performed; call the proper tool to send the email.\n" //
			+ "\nIncorrect Output:\n\n" //
			+ "CONTINUE\n" //
			+ "\n---\n\n" //
			+ "Input:\n\n" //
			+ "<steps>[...<several steps before last one>\n" //
			+ "{\n" //
			+ "  \"status\" : \"COMPLETED\",\n" //
			+ "  \"actor\" : <Executor ID here>,\n" //
			+ "  \"thought\" : \"The only remaining step is to close the task. I will now call the tool to close the task.\",\n" //
			+ "  \"observation\" : \"Task with ID 123 has been successfully closed. All required steps in the process have been performed and the user's command is fully executed.\"\n" //
			+ "}\n" //
			+ "}]\n" //
			+ "</steps>\n" //
			+ "\nCorrect Output:\n\n" //
			+ "There is no evidence you closed the task as needed, no action was performed; call the proper tool to close the task.\n" //
			+ "\nIncorrect Output:\n\n" //
			+ "CONTINUE\n" //
			+ "\n---\n\n" //
			+ "Input:\n\n" //
			+ "<steps>[...<several steps before...>\n" //
			+ "{\n" //
			+ "  \"actor\" : <Executor ID here>,\n" //
			+ "  \"thought\" : \"I need to retrieve J. Doe email address and other data.\",\n" //
			+ "  \"observation\" : \"Data about client J. Doe:\\n email:joe@doe.com\\n customer number: 4567\\n\",\n" //
			+ "  \"action\" : \"The tool \\\"getCustomerData\\\" has been called\",\n" //
			+ "  \"actionInput\" : \"{\\\"question\\\":\\\"Retrieve data for customer J. Doe.\\\"}\",\n" //
			+ "},\n" //
			+ "{\n" //
			+ "  \"actor\" : <Executor ID here>,\n" //
			+ "  \"thought\" : \"The next step is to send an email to J. Doe.\",\n" //
			+ "  \"observation\" : \"ERROR: Missing required information: J. Doe's unique customer number.\",\n" //
			+ "  \"action\" : \"The tool \\\"sendEmail\\\" has been called\",\n" //
			+ "  \"actionInput\" : \"{\\\"question\\\":\\\"Send an email to J. Doe (joe@doe.com) with the following content: \\\"Order received.\\\"\\\"}\",\n" //
			+ "}]\n" //
			+ "</steps>\n" //
			+ "\nCorrect Output:\n\n" //
			+ "The sendEmail tool requires a customer number; use the customer number 4567 as indicted in previous steps.\n" //
			+ "\nIncorrect Output:\n\n" //
			+ "The sendEmail tool requires a customer number. If you have J. Doe's customer number from previous steps, use that value.\n" //
			+ "\n---\n\n" //
			+ "Given the above examples, provide only the Correct Output for future inputs.\n"; //

	CriticModule(@NonNull ReactAgent agent, @NonNull List<? extends Tool> tools, @NonNull String model) {
		super(agent.getId() + "-critic", "Critic module for " + agent.getId() + " agent", new ArrayList<>());
		this.agent = agent;
		this.tools = new ArrayList<>(tools);
		setTemperature(0d);
		setModel(model);
	}

	/**
	 * Instructs the critic to review last tool call.
	 */
	public String reviewToolCall(@NonNull List<? extends Step> steps) throws JsonProcessingException {
		return review(REVIEW_TOOL_CALL_TEMPLATE, steps);
	}

	/**
	 * Instructs the critic to review last tool call.
	 */
	public String reviewConclusions(@NonNull List<? extends Step> steps) throws JsonProcessingException {
		return review(REVIEW_CONCLUSIONS_TEMPLATE, steps);
	}

	/**
	 * Instructs the critic to review last tool call.
	 */
	public String review(String template, @NonNull List<? extends Step> steps) throws JsonProcessingException {

		Map<String, String> map = new HashMap<>();
		map.put("command", agent.getExecutor().getCommand());
		map.put("executor_id", agent.getExecutor().getId());
		map.put("context", agent.getContext());
		map.put("tools", buildToolDescription(tools));
		map.put("steps", JsonSchema.serialize(steps));
		setPersonality(Agent.fillSlots(template, map));

		clearConversation();
		String suggestion = chat(Agent.fillSlots("<steps>\\n{{steps}}\\n</steps>", map)).getText();
		LOG.debug("    **** Suggestion: " + suggestion);
		return chat(Agent.fillSlots("<steps>\\n{{steps}}\\n</steps>", map)).getText();
	}

	private static String buildToolDescription(@NonNull List<Tool> tools) {
		StringBuilder sb = new StringBuilder();
		for (Tool t : tools) {
			sb.append("## Tool\n\n");
			sb.append("### Tool ID: ").append(t.getId()).append("\n");
			sb.append("### Tool Description\n").append(t.getDescription()).append("\n");
			sb.append("### Tool Paramters (as JSON schema\n").append(t.getJsonParameters()).append("\n\n");
		}
		return sb.toString();
	}

}

## ExecutorModule.java

/*
 * Copyright 2023 Massimiliano "Maxi" Zattera
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * 
 */
package com.infosys.small.react;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.infosys.small.core.Agent;
import com.infosys.small.core.ChatCompletion;
import com.infosys.small.core.JsonSchema;
import com.infosys.small.core.Tool;
import com.infosys.small.core.ToolCall;
import com.infosys.small.core.ToolCallResult;
import com.infosys.small.core.ChatCompletion.FinishReason;
import com.infosys.small.react.ReactAgent.Step;
import com.infosys.small.react.ReactAgent.ToolCallStep;
import com.infosys.small.react.ReactAgent.Step.Status;

import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

/**
 * This agent is an executor component, part of a {@link ReactAgent}; its task
 * is to execute user's commands using the tools at its disposal.
 */
class ExecutorModule extends Agent {

	private final static Logger LOG = LoggerFactory.getLogger(ExecutorModule.class);

	/**
	 * After this number of steps, we stop execution (to avoid loops).
	 */
	// TODO Urgent: make this configurable
	public final static int MAX_STEPS = 40;

	private static final String PROMPT_TEMPLATE = "# Identity\n\n" //
			+ "You are a ReAct (Reasoning and Acting) agent; your task is to execute the below user command in <user_command> tag.\n"
			+ "\n<user_command>\n{{command}}\n</user_command>\n\n" //
			+ "You will be provided by the user with a potentially empty list of execution steps, in <steps> tag, that you have already performed in an attempt to execute the user's command. The format of these steps is provided as a JSON schema in <step_format> tag below.\n"
			+ "\n<step_format>\n" + JsonSchema.getJsonSchema(ToolCallStep.class) + "\n</step_format>\n\n" //
			+ "Together with the list of steps, the user might provide a suggestion about how to execute next step.\n"
			+ "\n# Additional Context and Information\n\n" //
			+ " * You are identified with actor=={{id}} in execution steps." //
			+ "{{context}}\n\n" //
			+ "\n# Instructions\n\n" //
			+ "  * Carefully plan the steps required to execute the user's command, think it step by step.\n"
			+ "  * If the user provided a suggestion about how to progress execution, then **STRICTLY** and **IMPORTANTLY** follow that suggestion when planning next step. "
			+ "Notice that the suggestion can ask you to proceed even if last step has status==\"COMPLETED\" or status==\"ERROR\"; if this is the case, you **MUST** **STRICTLY** follow the suggestion."
			+ " **IMPORTANTLY** notice the suggestion refers only to next execution step; you still need to continue execution after that, to fully execute user's command eventually.\n"
			+ "  * At each new step, use the most suitable tool at your disposal to progress towards executing the user's command. **STRICTLY** and **IMPORTANTLY** **NEVER** output a step to indicate a tool call, but call the tool directly.\n"
			+ "  * Your tools do not have access to steps in <steps>, therefore you must pass them all the parameters they require with their corresponding values. Be very detailed and specific each time you issue a tool call.\n"
			+ "  * When calling a tool, be specific on the task you want the tool to accomplish, do not mention why you are calling the tool and what your next steps will be.\n"
			+ "  * When planning the next step, carefully consider all of the steps already executed that are contained in <steps> tag. Carefully consider the thought that caused you to call each tool, usually provided as \"thought\" field in \"actionInput\" field, and observe the result of the call in \"observation\" field, before planning next step.\n"
			+ "  * **IMPORTANTLY** Never state in \"observation\" field that an action was performed, unless you called the proper tool to perform it, and it returned no errors."
			+ "  * When you are completely done done with executing the user's command and no further steps are needed, and only in that case, output one final step with status=\"COMPLETED\".\n"
			+ "  * **STRICTLY** and **IMPORTANTLY** **NEVER** output a step with status=\"COMPLETED\" if you think there are still actions to be performed; call the proper tool instead."
			+ "  * If you are experiencing an error, try to act differently and recover from it; if you are unable to recover, output one final step with status=\"ERROR\".\n"
			+ "  * **IMPORTANTLY**, when you output a final step with status=\"ERROR\", clearly and in detail describe in the \"observation\" field the reason of your failure. If the command lacked any necessary information, list missing information clearly and in detail. Suggest to the user any change or additions they could do to the command to help you to execute it.\n"
			+ "  * **IMPORTANTLY**, in all other cases, use status=\"IN_PROGRESS\", **STRICTLY** try to avoid this, rather use tool calls if you still have steps left to execute."
			+ "  * The format of the last step to output is described by the below JSON schema in <output_schema> tag; use this very format when outputting the final step.\n" //
			+ "\n<output_schema>\n" + JsonSchema.getJsonSchema(Step.class) + "\n</output_schema>\n" + "\n# Examples\n\n" //
			+ "Input & Context:\n\n" //
			+ "<user_command>Update J. Doe data with newest information.</user_command> and you realize data for J. Doe is already up-to-date.\n" //
			+ "\nCorrect Output:\n\n" //
			+ "		{\n" //
			+ "		  \"status\" : \"COMPLETED\",\n" //
			+ "		  \"actor\" : <your ID here>,\n" //
			+ "		  \"thought\" : \"The system record for J. Doe matches the provided data, no update is needed.\",\n" //
			+ "		  \"observation\" : \"No action needed, I have completed execution of the command.\",\n" //
			+ "		}\n" //
			+ "\nIncorrect Output:\n\n" //
			+ "<Issuing a tool call>\n" //
			+ "\n---\n\n" //
			+ "Input & Context:\n\n" //
			+ "You think the only remaining step in the process is to send an email to the customer.\n" //
			+ "\nCorrect Output:\n\n" //
			+ "<Issuing a tool call to send the email>\n" //
			+ "\nIncorrect Output:\n\n" //
			+ "		{\n" //
			+ "		  \"status\" : \"COMPLETED\",\n" //
			+ "		  \"actor\" : <your ID here>,\n" //
			+ "		  \"thought\" : \"All required steps in the process have been performed; The only remaining step is to send email to customer.\",\n" //
			+ "		  \"observation\" : \"All process steps completed. The only remaining action is to send an email.\"\n" //
			+ "		}\n" //
			+ "\n---\n\n" //
			+ "Input & Context:\n\n" //
			+ "<steps>[...<several steps before last one>\n" //
			+ "		{\n" //
			+ "		  \"status\" : \"COMPLETED\",\n" //
			+ "		  \"actor\" : <your ID here>,\n" //
			+ "		  \"thought\" : \"All steps up to this point have been completed as per the process. I only need to create the corresponding log entry.\",\n" //
			+ "		  \"observation\" : The process is complete up to the current stage.\"\n" //
			+ "		}]\n" //
			+ "</steps>\n" //
			+ "Suggestion: \"You must proceed with the next required steps: create corresponding log entry\","
			+ "\nCorrect Output:\n\n" //
			+ "<Issuing a tool call to create the log entry>\n" //
			+ "\nIncorrect Output:\n\n" //
			+ "		{\n" //
			+ "		  \"status\" : \"COMPLETED\",\n" //
			+ "		  \"actor\" : <your ID here>,\n" //
			+ "		  \"thought\" : \"I only need to create the corresponding log entry.\",\n" //
			+ "		  \"observation\" : The process is complete up to the current stage.\"\n" //
			+ "		}\n" //
			+ "\n---\n\n" //
			+ "Input & Context:\n\n" //
			+ "You think the process requires that you send an email to the user." //
			+ "\nCorrect Output:\n\n" //
			+ "<Issuing a tool call to send the email>\n" //
			+ "\nIncorrect Output:\n\n" //
			+ "{\n" //
			+ "  \"actor\" : <your ID here>,\n" //
			+ "  \"thought\" : \"The process requires that I must send an email to the user.\",\n" //
			+ "  \"observation\" : \"Proceeding to send an email to user.\"\n" //
			+ "}\n" //
			+ "\n---\n\n" //
			+ "Input & Context:\n\n" //
			+ "<steps>[{\n" //
			+ "  \"actor\" : <your ID here>,\n" //
			+ "  \"thought\" : \"I am starting execution of the below user's command in <user_command> tag.\\n\\n<user_command>\\nSend an email to J. Doe\\n</user_command>\",\n" //
			+ "  \"observation\" : \"Execution just started.\"\n" //
			+ "}]</steps>\n" //
			+ "\nCorrect Output:\n\n" //
			+ "<Issuing a tool call to send the email>\n" //
			+ "\nIncorrect Output:\n\n" + "{\n" //
			+ "  \"status\" : \"COMPLETED\",\n" //
			+ "  \"actor\" : <your ID here>,\n" //
			+ "  \"thought\" : \"The user's command is to send an email to J. Doe. The only required action is to send the email as instructed.\",\n" //
			+ "  \"observation\" : \"The email to J. Doe has been sent as requested.\"\n" //
			+ "}\n" //
			+ "\n---\n\n" //
			+ "Input & Context:\n\n" //
			+ "<user_command>Assign oldest task to operator 42.</user_command>\n" //
			+ "<steps>[...<several steps before last one>\n" //
			+ "		{\n" //
			+ "		  \"actor\" : <your ID here>,\n" //
			+ "  \"observation\" : \"OK, task assigned\",\n" //
			+ "  \"thought\" : \"I will assign task with ID 5656 (oldest task) to Operator ID 42 as requested.\",\n" //
			+ "  \"action\" : \"The tool \\\"assignTask\\\" has been called\",\n" //
			+ "  \"actionInput\" : \"{\\\"taskID\\\":\\\"5656\",\\\"operatorId\\\":\\\"42\\\"}\",\n" //
			+ "}]</steps>\n" //
			+ "\nCorrect Output:\n\n" //
			+ "{" //
			+ "  \"status\" : \"COMPLETED\",\n" //
			+ "  \"actor\" : <your ID here>,\n" //
			+ "  \"thought\" : \"The oldest task (ID=5656) has been assigned to Operator ID 42.\"\n" //
			+ "  \"outcome\" : \"The task with ID 5656 has been successfully assigned to Operator ID 42.\"\n" //
			+ "}" //
			+ "\nIncorrect Output:\n\n" //
			+ "{\n" //
			+ "  \"actor\" : <your ID here>,\n" //
			+ "  \"thought\" : \"I want to double-check that the task assignment is reflected in the current list of tasks for Operator ID 42, ensuring the process is complete and the correct task is now assigned.\",\n" //
			+ "  \"observation\" : \"List of tasks assigned to operator 42 = [5656]\",\n" //
			+ "  \"action\" : \"The tool \\\"getTasksForOperatot\\\" has been called\",\n" //
			+ "  \"actionInput\" : \"{\\\"operatorId\\\":\\\"42\\\"}\",\n" //
			+ "}\n" //
			+ "\n---\n\n" //
			+ "Input & Context:\n\n" //
			+ "You want to call \"getTasks\" tool.\n" //
			+ "\nCorrect Output:\n\n" //
			+ "{\n" //
			+ "  \"actor\" : <your ID here>,\n" //
			+ "  \"thought\" : \"I need to check if all tasks assigned to Operator with ID 90 are already closed. If not, I will write a reminder for the operator.\",\n" //
			+ "  \"observation\" : \"No open tasks are assigned to Operator ID 90 have been closed.\",\n" //
			+ "  \"action\" : \"The tool \\\"getTasks\\\" has been called\",\n" //
			+ "  \"actionInput\" : \"{\\\"question\\\":\\\"For all tasks assigned to Operator ID 90, list all that are still open.\\\"}\",\n" //
			+ "} \n" //
			+ "\nIncorrect Output:\n\n" //
			+ "{\n" //
			+ "  \"actor\" : <your ID here>,\n" //
			+ "  \"thought\" : \"I need to check if all tasks assigned to Operator with ID 90 are already closed. If not, I will write a reminder for the operator.\",\n" //
			+ "  \"observation\" : \"No open tasks are assigned to Operator ID 90 have been closed.\",\n" //
			+ "  \"action\" : \"The tool \\\"getTasks\\\" has been called\",\n" //
			+ "  \"actionInput\" : \"{\\\"question\\\":\\\"For all tasks assigned to Operator ID 90, list all that are still open. If any, I will send a reminder to the operator.\\\"}\",\n" //
			+ "} \n" //
			+ "\n---\n\n" //
			+ "Given the above examples, provide only the Correct Output for future inputs and context.\n" //
			+ "\n## Other Examples\n\n" //
			+ "{{examples}}\n";

	/**
	 * This is the ReAct agent containing this executor component.
	 */
	@Getter
	private final @NonNull ReactAgent agent;

	/**
	 * If true, it will call the reviewer on last step before exiting. We do this to
	 * save tokens.
	 */
	@Getter
	@Setter
	private boolean checkLastStep;

	/**
	 * Current command being executed.
	 */
	@Getter
	private String command;

	/**
	 * The list of steps executed so far while executing current command.
	 */
	@Getter
	private final @NonNull List<Step> steps = new ArrayList<>();

	/**
	 * @return Last step so far (or null).
	 */
	public Step getLastStep() {
		return (steps.size() == 0) ? null : steps.get(steps.size() - 1);
	}

	/**
	 * Adds one step to the list of execution steps.
	 */
	public void addStep(Step step) {
		steps.add(step);

		// TODO Write step into the database, if a link to the database is provided
	}

	ExecutorModule(@NonNull ReactAgent agent, @NonNull List<? extends Tool> tools, boolean checkLastStep,
			@NonNull String model) {

		super(agent.getId() + "-executor", "Executor module for " + agent.getId() + " agent", tools);
		this.agent = agent;
		this.checkLastStep = checkLastStep;

		setTemperature(0d);
		setModel(model);
		setResponseFormat(Step.class);
	}

	public Step execute(@NonNull String command) throws JsonProcessingException {

		this.command = command;
		steps.clear();

		Map<String, String> map = new HashMap<>();
		map.put("command", command);
		map.put("id", getId());
		map.put("context", agent.getContext());
		map.put("examples", agent.getExamples());

		setPersonality(Agent.fillSlots(PROMPT_TEMPLATE, map));

		Step step = new Step.Builder() //
				.actor(getId()) //
				.status(Status.IN_PROGRESS) //
				.thought(Agent.fillSlots(
						"I am starting execution of the below user's command in <user_command> tag.\n\n<user_command>\n{{command}}\n</user_command>",
						map)) //
				.observation("Execution just started.") //
				.build();
		addStep(step);
		LOG.info(JsonSchema.prettyPrint(step));

		// execution loop
		String instructions = "<steps>\n{{steps}}\n</steps>\n\nSuggestion: {{suggestion}}";
		String suggestion = "No suggestions. Proceed as you see best, using the tools at your disposal.";
		while ((steps.size() < MAX_STEPS) && ((getLastStep() == null) || (getLastStep().status == null)
				|| (getLastStep().status == Status.IN_PROGRESS))) {

			clearConversation();
			
			// Strictly and importantly; when translating the below line of code into Python
			// you must serialize steps into a JSON array of Step but importantly excluding 
			// the actionStep field then serializing each step
			map.put("steps", JsonSchema.JSON_MAPPER.writerWithView(Step.Views.Compact.class).writeValueAsString(steps));
			
			map.put("suggestion", suggestion);
			String message = Agent.fillSlots(instructions, map);
			ChatCompletion reply = null;
			Exception ex = null;
			try {
				reply = chat(message);
			} catch (Exception e) { // Exception calling the LLM
				ex = e;
				LOG.error(e.getMessage(), e);
			}

			if ((ex != null) || (reply.getFinishReason() != FinishReason.COMPLETED)) { // Something went wrong calling
																						// the LLM
				step = new ToolCallStep.Builder() //
						.actor(getId()) //
						.status(Status.ERROR) //
						.thought("I had something in mind...") //
						.action("LLM was called but this resulted in "
								+ ((ex != null) ? "an error." : "a truncated message.")) //
						.actionInput(message) //
						.actionSteps(new ArrayList<>()) //
						.observation(
								(ex != null) ? ex.getMessage() : "Response finish reason: " + reply.getFinishReason()) //
						.build();
				addStep(step);
				LOG.info(JsonSchema.prettyPrint(step));
				break;
			}

			// Check if agent generated a function call
			if (reply.getMessage().hasToolCalls()) { // Agent called a tool

				List<ToolCallResult> results = new ArrayList<>();
				boolean withError = false; // See below
				for (ToolCall call : reply.getMessage().getToolCalls()) {

					// Execute each call, handling errors nicely
					ToolCallResult result;
					try {
						result = call.execute();
					} catch (Exception e) {
						result = new ToolCallResult(call, e);
						withError = true;
					}
					results.add(result);
					// TODO We should use a more generic way?
					withError |= result.getResult().toString().toLowerCase().contains("error");

					// Store the call and the results in steps
					Map<String, Object> args = new HashMap<>(call.getArguments());
					Object thought = args.remove("thought"); // Should always be provided
					step = new ToolCallStep.Builder() //
							.actor(getId()) //
							.status(Status.IN_PROGRESS) //
							.thought(thought == null ? "No thought passed explicitely." : thought.toString()) //
							.action("The tool \"" + call.getTool().getId() + "\" has been called") //
							.actionInput(JsonSchema.serialize(args)) //
							.actionSteps( // If the tool was another agent, store its steps too
									(call.getTool() instanceof ReactAgent) ? ((ReactAgent) call.getTool()).getSteps()
											: new ArrayList<>()) //
							.observation(result.getResult().toString()).build();

					addStep(step);
					LOG.info(JsonSchema.prettyPrint(step));

					if (steps.size() > MAX_STEPS)
						break;
				} // for each tool call, in case of parallel calls

				if (steps.size() <= MAX_STEPS) {
					// Trick to save time and tokens; maybe remove :)
					if (withError)
						suggestion = agent.getReviewer().reviewToolCall(steps);
					else
						suggestion = "CONTINUE";
				}
			} else { // Agent output something different than a tool call

				try {
					step = reply.getObject(Step.class);
					step.actor = getId();
					addStep(step);
					LOG.info(JsonSchema.prettyPrint(step));
				} catch (JsonProcessingException e) { // Paranoid
					step = new Step.Builder() //
							.actor(getId()) //
							.thought("I stopped because I encountered this error: " + e.getMessage()) //
							.observation(reply.getText()) //
							.status(Step.Status.ERROR).build();
					addStep(step);
					LOG.info(JsonSchema.prettyPrint(step));
				}

				// Check the result
				if (getLastStep().status == Status.IN_PROGRESS) {
					suggestion = "**STRICTLY** proceed with next steps, by calling appropriate tools.";
				} else if (checkLastStep) { // Configurable, to decide in which component we check
					// Try to recover errors
					suggestion = agent.getReviewer().reviewConclusions(steps);
					if (!suggestion.toLowerCase().contains("continue")) {
						// forces the conversation to continue
//						steps.remove(getLastStep());
						getLastStep().status = Status.IN_PROGRESS;
//						getLastStep().status = null;
					}
				}
			}
		} // loop until the command is executed

		// If execution was interrupted, output a final error message
		if (steps.size() >= MAX_STEPS) {
			step = new Step.Builder() //
					.actor(getId()) //
					.thought("Execution was stopped because it exceeded maximum number of steps (" + MAX_STEPS + ").") //
					.observation("I probably entered some kind of loop.") //
					.status(Step.Status.ERROR).build();
			addStep(step);
			LOG.error(JsonSchema.prettyPrint(step));
		}

		return getLastStep();
	}
}

## ReactAgent.java

package com.infosys.small.react;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.annotation.JsonView;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.infosys.small.core.Agent;
import com.infosys.small.core.JsonSchema;
import com.infosys.small.core.Tool;
import com.kjetland.jackson.jsonSchema.annotations.JsonSchemaDescription;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.Setter;

/**
 * This implements a generic ReAct agent.
 */
public class ReactAgent extends Agent {

	public static final String DEFAULT_MODEL = "gpt-4.1";
//	public static final String DEFAULT_MODEL = "gpt-4o";
//	public static final String DEFAULT_MODEL = "o3";

	/**
	 * Base class for {@link Tool} parameters for those tools that are available to
	 * a ReAct agent. They must all accept at least a thought parameter.
	 */
	@NoArgsConstructor
	public static class Parameters {

		@JsonProperty(required = true)
		@JsonPropertyDescription("Your reasoning about why this tool has been called.")
		public @NonNull String thought;
	}

	@NoArgsConstructor
	@JsonSchemaDescription("This represent the final execution step performed by a ReAct agent.")
	public static class Step {

		public static class Views {
			public interface Compact {
			}

			public interface Complete extends Compact {
			}
		}

		public enum Status {
			IN_PROGRESS, COMPLETED, ERROR
		};

		@JsonPropertyDescription("If you finish the execution or you experience an unrecoverable error, set this to either COMPLETED or ERROR respectively.")
		@JsonView(Views.Compact.class)
		public Status status;

		// Do not remove it's OK it stays here
		@JsonPropertyDescription("The tool or agent that executed this step. This is provided automatically, so you do not need to output it.")
		@JsonView(Views.Compact.class)
		public @NonNull String actor;

		@JsonProperty(required = true)
		@JsonPropertyDescription("Your reasoning about why and how accomplish this step.")
		@JsonView(Views.Compact.class)
		public @NonNull String thought;

		@JsonProperty(required = true)
		@JsonPropertyDescription("Any additional data, like step outcomes, error messages, etc..")
		@JsonView(Views.Compact.class)
		public @NonNull String observation;

		// Private constructor to force use of the builder
		private Step(Builder builder) {
			this.status = builder.status;
			this.actor = Objects.requireNonNull(builder.actor, "id must not be null");
			this.thought = Objects.requireNonNull(builder.thought, "thought must not be null");
			this.observation = Objects.requireNonNull(builder.observation, "observation must not be null");
		}

		/**
		 * Builder for Step.
		 */
		public static class Builder {
			private Status status;
			private String actor;
			private String thought;
			private String observation;

			public Builder status(Status status) {
				this.status = status;
				return this;
			}

			public Builder actor(@NonNull String actor) {
				this.actor = actor;
				return this;
			}

			public Builder thought(@NonNull String thought) {
				this.thought = thought;
				return this;
			}

			public Builder observation(@NonNull String observation) {
				this.observation = observation;
				return this;
			}

			public Step build() {
				return new Step(this);
			}
		}
	}

	@NoArgsConstructor
	@JsonSchemaDescription("This extends execution step to cover function calls")
	public static class ToolCallStep extends Step {

		@JsonProperty(required = true)
		@JsonPropertyDescription("The action that was taken at this step. It is typically a tool invocation.")
		@JsonView(Views.Compact.class)
		public @NonNull String action;

		@JsonProperty(required = true, value = "action_input")
		@JsonPropertyDescription("Input for the action.")
		@JsonView(Views.Compact.class)
		public @NonNull String actionInput;

		@JsonProperty(required = true, value = "action_steps")
		@JsonPropertyDescription("In case the action for this step was delegated to another agent, this is the list of steps that agent performed to complete the action.")
		@JsonView(Views.Complete.class)
		public @NonNull List<Step> actionSteps;

		private ToolCallStep(Builder builder) {
			super(builder);
			this.action = Objects.requireNonNull(builder.action, "action must not be null");
			this.actionInput = Objects.requireNonNull(builder.actionInput, "actionInput must not be null");
			this.actionSteps = new ArrayList<>(builder.actionSteps);
		}

		/**
		 * Builder for ToolCallStep.
		 */
		public static class Builder extends Step.Builder {
			private String action;
			private String actionInput;
			public List<Step> actionSteps = new ArrayList<>();

			@Override
			public Builder status(Status status) {
				return (Builder) super.status(status);
			}

			@Override
			public Builder actor(@NonNull String actor) {
				return (Builder) super.actor(actor);
			}

			@Override
			public Builder thought(@NonNull String thought) {
				return (Builder) super.thought(thought);
			}

			@Override
			public Builder observation(@NonNull String observation) {
				return (Builder) super.observation(observation);
			}

			public Builder action(@NonNull String action) {
				this.action = action;
				return this;
			}

			public Builder actionInput(@NonNull String actionInput) {
				this.actionInput = actionInput;
				return this;
			}

			public Builder actionSteps(@NonNull List<? extends Step> steps) {
				this.actionSteps = new ArrayList<>(steps);
				return this;
			}

			public Builder addAllSteps(@NonNull List<? extends Step> steps) {
				this.actionSteps.addAll(steps);
				return this;
			}

			public Builder addStep(@NonNull Step step) {
				this.actionSteps.add(step);
				return this;
			}

			@Override
			public ToolCallStep build() {
				return new ToolCallStep(this);
			}
		}
	}

	/**
	 * Any additional context you want to provide to the agent.
	 */
	@Getter
	@Setter
	private @NonNull String context = "";

	/**
	 * Any additional examples you want to provide to the agent.
	 */
	@Getter
	@Setter
	private @NonNull String examples = "";

	@Getter(AccessLevel.PROTECTED)
	private final @NonNull ExecutorModule executor;

	@Getter(AccessLevel.PROTECTED)
	private final @NonNull CriticModule reviewer;

	// TODO Make it a wrapper of another agent instead? A lot of code forwarding...

	public ReactAgent(@NonNull String id, @NonNull String description, @NonNull List<? extends Tool> tools,
			boolean checkLastStep) {

		// Only executor is using tools
		super(id, description, new ArrayList<>());
		setModel(DEFAULT_MODEL);
		setTemperature(0d);

		this.executor = new ExecutorModule(this, tools, checkLastStep, DEFAULT_MODEL);
		this.reviewer = new CriticModule(this, tools, DEFAULT_MODEL);
	}

	public Step execute(@NonNull String command) throws JsonProcessingException {
		return executor.execute(command);
	}

	public List<Step> getSteps() {
		return executor.getSteps();
	}

	public static void main(String[] args) {
		System.out.println(JsonSchema.getJsonSchema(ToolCallStep.class));
	}
}

## ToolableReactAgent.java

package com.infosys.small.react;

import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.infosys.small.core.Agent;
import com.infosys.small.core.JsonSchema;
import com.infosys.small.core.Tool;
import com.infosys.small.core.ToolCall;
import com.infosys.small.core.ToolCallResult;
import com.kjetland.jackson.jsonSchema.annotations.JsonSchemaDescription;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

/**
 * This is a {@link ReactAgent} wrapped into a {@link Tool}, so it can be used
 * as a tool by other agents.
 */
public class ToolableReactAgent extends ReactAgent implements Tool {

	// TODO Maybe merge with ReactAgent? Might be a 6good idea to keep 7tool
	// interface separated though
	// TODO Maybe better to have a Tool wrapped as inner class rather than implement
	// all get methods?

	@JsonSchemaDescription("This describes parameters needed to call an execution agent")
	public static class Parameters extends ReactAgent.Parameters {

		@JsonProperty(required = true)
		@JsonPropertyDescription("A question that this tool must answer or a command it must execute.")
		public String question;
	}

	/**
	 * Description for this tool.
	 */
	@Getter
	private String description = "";

	/**
	 * JSON schema describing parameters for this tool.
	 */
	@Getter
	private final String jsonParameters;

	/**
	 * True if this tool has been closed already.
	 */
	@Getter
	@Setter(AccessLevel.PROTECTED)
	private boolean closed = false;

	/**
	 * Agent using this tool.
	 */
	@Getter
	private Agent agent;

	/**
	 * @return True if the tool has been initialized.
	 */
	@Override
	public boolean isInitialized() {
		return (getAgent() != null);
	}

	@Override
	public void init(@NonNull Agent agent) {
		if (isInitialized())
			throw new RuntimeException("Tool " + getId() + " is already initialized");
		if (closed)
			throw new RuntimeException("Tool " + getId() + " is already closed");
		this.agent = agent;
	}

	public ToolableReactAgent(@NonNull String id, @NonNull String description, @NonNull List<? extends Tool> tools,
			boolean checkLastStep) {

		super(id, description, tools, checkLastStep);
		jsonParameters = JsonSchema.getJsonSchema(Parameters.class);
	}

	@Override
	public ToolCallResult invoke(@NonNull ToolCall call) throws Exception {
		if (!isInitialized())
			throw new IllegalStateException("Tool must be initialized.");

		String question = getString("question", call.getArguments());
		if (question == null)
			return new ToolCallResult(call, "ERROR: You must provide a command to execute as \"question\" parameter.");

		Step result = execute(question);
		switch (result.status) {
		case ERROR:
			return new ToolCallResult(call, "ERROR: " + result.observation);
		default:
			return new ToolCallResult(call, result.observation);
		}
	}

	@Override
	public void close() {
		closed = true;
		super.close();
	}

	// Utility methods to read parameters
	// TODO URGENT be smarter
	// ////////////////////////////////////////////////////////////////////////////////////////////

	protected static boolean getBoolean(String name, Map<String, ? extends Object> args) {
		if (args.containsKey(name))
			return getBoolean(name, args.get(name));
		throw new IllegalArgumentException("Missing required parameter \"" + name + "\".");
	}

	protected static boolean getBoolean(String name, Map<String, ? extends Object> args, boolean def) {
		if (!args.containsKey(name))
			return def;
		return getBoolean(name, args.get(name));
	}

	private static boolean getBoolean(String name, Object value) {
		String s = value.toString();
		if ("true".equals(s.trim().toLowerCase()))
			return true;
		if ("false".equals(s.trim().toLowerCase()))
			return false;

		throw new IllegalArgumentException(
				"Parameter \"" + name + "\" is expected to be a boolean value but it is not.");
	}

	protected static long getLong(String name, Map<String, ? extends Object> args) {
		if (args.containsKey(name))
			return getLong(name, args.get(name));
		throw new IllegalArgumentException("Missing required parameter \"" + name + "\".");
	}

	protected static long getLong(String name, Map<String, ? extends Object> args, long def) {
		if (!args.containsKey(name))
			return def;
		return getLong(name, args.get(name));
	}

	private static long getLong(String name, Object value) {
		try {
			return Long.parseLong(value.toString());
		} catch (Exception e) {
			throw new IllegalArgumentException(
					"Parameter \"" + name + "\" is expected to be a integer value but it is not.");
		}
	}

	protected static double getDouble(String name, Map<String, ? extends Object> args) {
		if (args.containsKey(name))
			return getDouble(name, args.get(name));
		throw new IllegalArgumentException("Missing required parameter \"" + name + "\".");
	}

	protected static double getDouble(String name, Map<String, ? extends Object> args, double def) {
		if (!args.containsKey(name))
			return def;
		return getDouble(name, args.get(name));
	}

	protected static double getDouble(String name, Object value) {
		try {
			return Double.parseDouble(value.toString());
		} catch (Exception e) {
			throw new IllegalArgumentException(
					"Parameter \"" + name + "\" is expected to be a decimal number but it is not.");
		}
	}

	protected static String getString(String name, Map<String, ? extends Object> args) {
		Object result = args.get(name);
		if (result == null)
			return null;
		return result.toString();
	}

	protected static String getString(String name, Map<String, ? extends Object> args, String def) {
		if (!args.containsKey(name))
			return def;
		return getString(name, args);
	}
}

</java>

<python>

## json_schema.py

from __future__ import annotations

import json
from typing import Type, TypeVar
from pydantic import BaseModel, TypeAdapter

T = TypeVar("T", bound=BaseModel)

class JsonSchema:
    """
    Python version of the Java JsonSchema utility class.
    Provides methods for:
    1. Getting a JSON schema from a Pydantic model.
    2. Serializing a Pydantic model instance to JSON.
    3. Deserializing a JSON string to a Pydantic model instance.
    """

    @staticmethod
    def get_json_schema(cls: type[BaseModel]) -> str:
        """
        Returns the JSON schema (draft-07) for the given Pydantic model class.

        Args:
            cls: The Pydantic model class.

        Returns:
            A string containing the JSON schema for the class.
        """
        return json.dumps(cls.model_json_schema(), separators=(",", ":"))

    @staticmethod
    def serialize(obj: BaseModel) -> str:
        """
        Serializes a Pydantic model instance to a JSON string, omitting fields whose value is None.

        Args:
            obj: The Pydantic model instance.

        Returns:
            The JSON string representation of the model.
        """
        return obj.model_dump_json(exclude_none=True)

    @staticmethod
    def deserialize(json_str: str, cls: Type[T]) -> T:
        """
        Deserializes a JSON string into an instance of the specified Pydantic model class,
        ignoring unknown fields.

        Args:
            json_str: The JSON string to deserialize.
            cls: The Pydantic model class.

        Returns:
            An instance of the specified model class.
        """
        adapter = TypeAdapter(cls)
        return adapter.validate_json(json_str, strict=False)
        
## tool.py 

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from typing import Any, Mapping, Type

# --------------------------------------------------------------------------- #
# Logging configuration (equivalent to Java SimpleLogger)
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------- #
# Forward references to avoid circular imports
# --------------------------------------------------------------------------- #
if False:  # type-checking only
    from agent import Agent
    from tool_call import ToolCall
    from tool_call_result import ToolCallResult

from json_schema import JsonSchema  # noqa: E402  (local project import)


# --------------------------------------------------------------------------- #
# Tool ­– Python equivalent of the Java interface
# --------------------------------------------------------------------------- #
class Tool(ABC):
    """
    Base protocol for every tool the agent can call.
    Sub-classes must implement :meth:`invoke`.
    """

    # --------------------------------------------------------------------- #
    # Public attributes expected by the agent
    # --------------------------------------------------------------------- #
    id: str
    description: str
    json_parameters: str

    # --------------------------------------------------------------------- #
    # Life-cycle hooks
    # --------------------------------------------------------------------- #
    @abstractmethod
    def is_initialized(self) -> bool: ...

    @abstractmethod
    def is_closed(self) -> bool: ...

    @abstractmethod
    def init(self, agent: "Agent") -> None: ...

    # --------------------------------------------------------------------- #
    # Core functionality
    # --------------------------------------------------------------------- #
    @abstractmethod
    def invoke(self, call: "ToolCall") -> "ToolCallResult": ...

    @abstractmethod
    def close(self) -> None: ...


# --------------------------------------------------------------------------- #
# AbstractTool ­– shared implementation for concrete tools
# --------------------------------------------------------------------------- #
class AbstractTool(Tool):
    """
    Convenient super-class that handles common responsibilities:
    * life-cycle management (`init`, `close`)
    * JSON-schema generation for parameters
    * helper methods to parse arguments passed as strings

    Parameters
    ----------
    id_ : str
        Unique identifier for the tool (used by the agent and the model).
    description : str, optional
        Human-readable description of the tool’s purpose.
    parameters_cls : type
        A class (typically a *pydantic* model) describing the tool parameters.
        Its JSON schema is exposed through :pyattr:`json_parameters`.
    """

    # --------------------------------------------------------------------- #
    # Construction & life-cycle
    # --------------------------------------------------------------------- #
    def __init__(
        self,
        id_: str,
        description: str | None = None,
        parameters_cls: Type | None = None,
    ) -> None:
        if id_ is None:
            raise ValueError("id_ must not be None")
        if description is None:
            raise ValueError("description must not be None")
        if parameters_cls is None:
            raise ValueError("parameters_cls must not be None")

        self.id: str = id_
        self.description: str = description
        self.json_parameters: str = JsonSchema.get_json_schema(parameters_cls)

        self._agent: "Agent | None" = None
        self._closed: bool = False

    # --------------------------------------------------------------------- #
    # Life-cycle helpers
    # --------------------------------------------------------------------- #
    def is_initialized(self) -> bool:
        return self._agent is not None

    def is_closed(self) -> bool:
        return self._closed

    def init(self, agent: "Agent") -> None:
        if agent is None:
            raise ValueError("agent must not be None")
        if self.is_initialized():
            raise RuntimeError(f"Tool {self.id} is already initialized")
        if self.is_closed():
            raise RuntimeError(f"Tool {self.id} is already closed")

        self._agent = agent
        logger.debug("Tool %s initialised", self.id)

    def close(self) -> None:
        self._closed = True
        logger.debug("Tool %s closed", self.id)

    # --------------------------------------------------------------------- #
    # Static helpers for argument parsing
    # --------------------------------------------------------------------- #
    @staticmethod
    def get_boolean(name: str, args: Mapping[str, Any], default: bool | None = None) -> bool:
        if name not in args:
            if default is not None:
                return default
            raise ValueError(f'Missing required parameter "{name}".')

        value = args[name]
        if isinstance(value, bool):
            return value
        if isinstance(value, str):
            s = value.strip().lower()
            if s == "true":
                return True
            if s == "false":
                return False

        raise ValueError(f'Parameter "{name}" is expected to be a boolean value but it is not.')

    @staticmethod
    def get_long(name: str, args: Mapping[str, Any], default: int | None = None) -> int:
        if name not in args:
            if default is not None:
                return default
            raise ValueError(f'Missing required parameter "{name}".')

        try:
            return int(args[name])
        except Exception as exc:  # noqa: BLE001
            raise ValueError(f'Parameter "{name}" is expected to be an integer value but it is not.') from exc

    @staticmethod
    def get_double(name: str, args: Mapping[str, Any], default: float | None = None) -> float:
        if name not in args:
            if default is not None:
                return default
            raise ValueError(f'Missing required parameter "{name}".')

        try:
            return float(args[name])
        except Exception as exc:  # noqa: BLE001
            raise ValueError(f'Parameter "{name}" is expected to be a decimal number but it is not.') from exc

    @staticmethod
    def get_string(name: str, args: Mapping[str, Any], default: str | None = None) -> str | None:
        if name not in args:
            return default
        value = args[name]
        return None if value is None else str(value)
        
## ChatMessage and related classes


from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from collections.abc import Sequence
from typing import Any, Mapping, overload, Self, Type, TypeVar

from json_schema import JsonSchema

# Forward‑references to avoid circular imports at type‑checking time
if False:  # pragma: no cover
    from agent import Agent
    from tool import Tool  # AbstractTool & Tool live in the project
    from tool_call_result import ToolCallResult  # noqa: F401

# --------------------------------------------------------------------------- #
# Logging configuration (equivalent to Java SimpleLogger)
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------- #
# MessagePart – marker interface
# --------------------------------------------------------------------------- #
class MessagePart(ABC):
    """A piece of a :class:`ChatMessage`."""

    @abstractmethod
    def get_content(self) -> str:
        """Return a textual representation of this part (best‑effort)."""

    # ------------------------------------------------------------------ #
    # Pythonic alias
    # ------------------------------------------------------------------ #
    def __str__(self) -> str:  # pragma: no cover
        return self.get_content()


# --------------------------------------------------------------------------- #
# TextPart – simple textual message part
# --------------------------------------------------------------------------- #
class TextPart(MessagePart):
    """A :class:`MessagePart` containing plain text."""

    def __init__(self, content: str) -> None:
        if content is None:
            raise ValueError("content must not be None")
        self._content: str = str(content)

    # Property to honour @NonNull semantics
    @property
    def content(self) -> str:
        return self._content

    @content.setter
    def content(self, value: str) -> None:
        if value is None:
            raise ValueError("content must not be None")
        self._content = str(value)

    # MessagePart ------------------------------------------------------ #
    def get_content(self) -> str:
        return self._content


# --------------------------------------------------------------------------- #
# ToolCall – a single invocation of a Tool
# --------------------------------------------------------------------------- #
class ToolCall(MessagePart):
    """Represents a single invocation of a :class:`Tool`."""

    def __init__(
        self,
        id_: str,
        tool: "Tool",
        arguments: Mapping[str, Any] | None = None,
    ) -> None:
        if id_ is None:
            raise ValueError("id_ must not be None")
        if tool is None:
            raise ValueError("tool must not be None")

        self.id: str = id_
        self.tool: "Tool" = tool
        self.arguments: dict[str, Any] = dict(arguments or {})

    # ----------------------- builder helpers -------------------------- #
    class Builder:
        """Fluent builder replicating the Java pattern."""

        def __init__(self) -> None:
            self._id: str | None = None
            self._tool: "Tool | None" = None
            self._arguments: dict[str, Any] = {}

        # id
        def id(self, id_: str) -> Self:  # noqa: D401 (“Returns self”)
            if id_ is None:
                raise ValueError("id must not be None")
            self._id = id_
            return self

        # tool
        def tool(self, tool: "Tool") -> Self:  # noqa: D401
            if tool is None:
                raise ValueError("tool must not be None")
            self._tool = tool
            return self

        # arguments – mapping
        def arguments(self, args: Mapping[str, Any]) -> Self:  # noqa: D401
            if args is None:
                raise ValueError("args must not be None")
            self._arguments = dict(args)
            return self

        # arguments – JSON string
        def arguments_json(self, json_str: str) -> Self:  # noqa: D401
            from typing import TypeAlias
            import json as _json

            _Map: TypeAlias = dict[str, Any]
            self._arguments = JsonSchema.deserialize(json_str, _Map)  # type: ignore[type-var]
            return self

        # Build
        def build(self) -> "ToolCall":
            return ToolCall(
                id_=self._id or (lambda: (_ for _ in ()).throw(ValueError("id not set")))(),  # trick to raise
                tool=self._tool or (lambda: (_ for _ in ()).throw(ValueError("tool not set")))(),
                arguments=self._arguments,
            )

    # Mimic Java's static builder() method
    @staticmethod
    def builder() -> "ToolCall.Builder":
        return ToolCall.Builder()

    # ------------------------------------------------------------------ #
    # MessagePart
    # ------------------------------------------------------------------ #
    def get_content(self) -> str:
        return f"ToolCall(id={self.id}, tool={self.tool.id}, args={self.arguments})"

    # ------------------------------------------------------------------ #
    # Execution helper
    # ------------------------------------------------------------------ #
    def execute(self) -> "ToolCallResult":
        """Invoke the underlying tool and return its result."""
        if self.tool is None:
            raise RuntimeError("Cannot execute a ToolCall without a bound Tool")
        return self.tool.invoke(self)  # type: ignore[return-value]


# --------------------------------------------------------------------------- #
# ToolCallResult – holds the outcome of a ToolCall
# --------------------------------------------------------------------------- #
class ToolCallResult(MessagePart):
    """Result (or error) produced by a :class:`ToolCall`."""

    def __init__(
        self,
        tool_call_id: str,
        tool_id: str,
        result: str | None = None,
        is_error: bool = False,
    ) -> None:
        if tool_call_id is None:
            raise ValueError("tool_call_id must not be None")
        if tool_id is None:
            raise ValueError("tool_id must not be None")

        self.tool_call_id: str = tool_call_id
        self.tool_id: str = tool_id
        self.result: str | None = result
        self.is_error: bool = is_error

    # Convenience constructors matching Java behaviour ----------------- #
    @classmethod
    def from_call(cls, call: ToolCall, result: str | None) -> "ToolCallResult":
        return cls(call.id, call.tool.id, result)

    @classmethod
    def from_exception(cls, call: ToolCall, exc: Exception) -> "ToolCallResult":
        return cls(call.id, call.tool.id, f"Error: {exc}", is_error=True)

    # ------------------------------------------------------------------ #
    # MessagePart
    # ------------------------------------------------------------------ #
    def get_content(self) -> str:
        label = "*ERROR* " if self.is_error else ""
        body = "" if self.result is None else str(self.result)
        return f"ToolCallResult({label}{body})"


# --------------------------------------------------------------------------- #
# ChatMessage – exchanged between user and agent
# --------------------------------------------------------------------------- #
class ChatMessage:
    """A single chat message, possibly composed of multiple parts."""

    # --------------------------- author -------------------------------- #
    class Author(str):
        """Enumeration of possible message authors."""

        USER = "user"
        BOT = "bot"
        DEVELOPER = "developer"

        def __new__(cls, value: str):
            return str.__new__(cls, value)

    # ------------------------- construction ---------------------------- #
    @overload
    def __init__(self, content: str, author: "ChatMessage.Author" = Author.USER) -> None: ...
    @overload
    def __init__(self, part: MessagePart, author: "ChatMessage.Author" = Author.USER) -> None: ...
    @overload
    def __init__(
        self,
        parts: Sequence[MessagePart],
        author: "ChatMessage.Author" = Author.USER,
    ) -> None: ...

    def __init__(
        self,
        first: str | MessagePart | Sequence[MessagePart],
        author: "ChatMessage.Author" = Author.USER,
    ) -> None:
        if author is None:
            raise ValueError("author must not be None")

        self.author: ChatMessage.Author = author
        self.parts: list[MessagePart] = []

        # Normalise input
        if isinstance(first, str):
            self.parts.append(TextPart(first))
        elif isinstance(first, MessagePart):
            self.parts.append(first)
        else:  # iterable of parts
            self.parts.extend(first)

    # ------------------------------------------------------------------ #
    # Public helpers (mirroring Java API)
    # ------------------------------------------------------------------ #
    def is_text(self) -> bool:
        """Return *True* iff every part is a :class:`TextPart`."""
        return all(isinstance(p, TextPart) for p in self.parts)

    def has_text(self) -> bool:
        return any(isinstance(p, TextPart) for p in self.parts)

    def get_text_content(self) -> str:
        return "\n\n".join(p.get_content() for p in self.parts)

    T_co = TypeVar("T_co")

    def get_object_content(self, cls: Type[T_co]) -> T_co:
        return JsonSchema.deserialize(self.get_text_content(), cls)

    # --- tool‑calls ---------------------------------------------------- #
    def has_tool_calls(self) -> bool:
        from tool_call import ToolCall  # local import to avoid cyclic deps

        return any(isinstance(p, ToolCall) for p in self.parts)

    def get_tool_calls(self) -> list["ToolCall"]:
        from tool_call import ToolCall  # local import to avoid cyclic deps

        return [p for p in self.parts if isinstance(p, ToolCall)]

    def has_tool_call_results(self) -> bool:
        from tool_call_result import ToolCallResult  # local import

        return any(isinstance(p, ToolCallResult) for p in self.parts)

    def get_tool_call_results(self) -> list["ToolCallResult"]:
        from tool_call_result import ToolCallResult  # local import

        return [p for p in self.parts if isinstance(p, ToolCallResult)]

    # ------------------------------------------------------------------ #
    # Representation helpers
    # ------------------------------------------------------------------ #
    def __str__(self) -> str:  # pragma: no cover
        return f"{self.author}: {self.get_text_content()}"

    __repr__ = __str__


# --------------------------------------------------------------------------- #
# ChatCompletion – wraps a model’s reply
# --------------------------------------------------------------------------- #
class ChatCompletion:
    """Encapsulates the reply produced by a language‑model."""

    # --------------------------- finish reasons ------------------------ #
    class FinishReason(str):
        IN_PROGRESS = "in_progress"
        COMPLETED = "completed"
        TRUNCATED = "truncated"
        INAPPROPRIATE = "inappropriate"
        OTHER = "other"

        def __new__(cls, value: str):
            return str.__new__(cls, value)

    # --------------------------- life‑cycle ---------------------------- #
    def __init__(
        self,
        finish_reason: "ChatCompletion.FinishReason",
        message: ChatMessage,
    ) -> None:
        if finish_reason is None:
            raise ValueError("finish_reason must not be None")
        if message is None:
            raise ValueError("message must not be None")

        self.finish_reason: ChatCompletion.FinishReason = finish_reason
        self.message: ChatMessage = message

    # ------------------------------------------------------------------ #
    # Convenience
    # ------------------------------------------------------------------ #
    def get_text(self) -> str:
        return self.message.get_text_content()

    T_co = TypeVar("T_co")

    def get_object(self, cls: Type[T_co]) -> T_co:
        """Parse the textual content as JSON into *cls*."""
        return self.message.get_object_content(cls)

## agent.py

"""agent.py

Python translation of the Java `Agent` class.

The implementation mirrors the original behaviour while embracing Pythonic
conventions and the `openai` Python SDK.

Dependencies
------------
- openai                (official OpenAI SDK)
- json                  (standard library)
- logging               (standard library)
- chat_types.ChatMessage, chat_types.ChatCompletion,
  chat_types.ToolCall, chat_types.ToolCallResult, chat_types.TextPart
- tool.Tool             (protocol / abstract base class for tools)
- json_schema.JsonSchema
"""

from __future__ import annotations

import json
import logging
import os
from collections.abc import Iterable, Sequence
from typing import Any, Dict, List, Mapping, MutableMapping, Type

import openai

from chat_types import (
    ChatCompletion,
    ChatMessage,
    TextPart,
    ToolCall,
    ToolCallResult,
)
from json_schema import JsonSchema
from tool import Tool

# --------------------------------------------------------------------------- #
# Logging (equivalent to Java SimpleLogger)
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------- #
# Agent
# --------------------------------------------------------------------------- #
class Agent:
    """
    An *Agent* that uses OpenAI’s Chat Completions API.

    Parameters
    ----------
    id_ : str
        Unique identifier for the agent.
    description : str
        Human-readable description of the agent’s capabilities.
    tools : Iterable[Tool], optional
        Tools that the agent can invoke.
    """

    DEFAULT_MODEL: str = "gpt-4.1"

    # -------------------------- construction --------------------------- #
    def __init__(
        self,
        id_: str = "OpenAIChatCompletionService",
        description: str = "Test agent",
        tools: Iterable[Tool] | None = None,
    ) -> None:
        if id_ is None:
            raise ValueError("id_ must not be None")
        if description is None:
            raise ValueError("description must not be None")

        self.id: str = id_
        self.description: str = description

        # Tools --------------------------------------------------------- #
        self._tool_map: Dict[str, Tool] = {}
        for tool in tools or []:
            if tool is None:
                raise ValueError("tools must not contain None")
            tool.init(self)
            self._tool_map[tool.id] = tool

        # Conversation state ------------------------------------------- #
        self.history: List[ChatMessage] = []
        self.max_history_length: int = float("inf")  # no hard limit
        self.max_conversation_steps: int = float("inf")

        # Model configuration ------------------------------------------ #
        self.model: str = self.DEFAULT_MODEL
        self.temperature: float = 0.0
        self.personality: str | None = None
        self._response_format: str | None = None

        # OpenAI configuration ----------------------------------------- #
        # Expect OPENAI_API_KEY in the environment
        openai.api_key = os.getenv("OPENAI_API_KEY")

    # --------------------------- utils -------------------------------- #
    # Conversation helpers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    def clear_conversation(self) -> None:
        """Start a new chat (clears stored history)."""
        self.history.clear()

    # Personality / response-format ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    @property
    def response_format(self) -> str | None:
        return self._response_format

    def set_response_format(self, schema: Type) -> None:
        """Define an explicit JSON schema for model outputs."""
        if schema is None:
            raise ValueError("schema must not be None")
        self._response_format = JsonSchema.get_json_schema(schema)

    # --------------------- public chat API ---------------------------- #
    def chat(self, message: str | ChatMessage | Sequence[ChatMessage]) -> ChatCompletion:
        """
        Continue the ongoing conversation with *message*.

        The provided message(s) are appended to the conversation, the LLM is
        queried, and the reply is stored in the history.
        """
        # Normalise input
        if isinstance(message, str):
            new_messages = [ChatMessage(message)]
        elif isinstance(message, ChatMessage):
            new_messages = [message]
        else:
            new_messages = list(message)

        # Build conversation context
        conversation: List[ChatMessage] = list(self.history) + new_messages
        self._trim_conversation(conversation)

        # Call the model
        completion = self._chat_completion(conversation)

        # Update history (respecting max_history_length)
        self.history.extend(new_messages)
        self.history.append(completion.message)
        if len(self.history) > self.max_history_length:
            del self.history[: len(self.history) - self.max_history_length]

        return completion

    # ------------------------------------------------------------------ #
    # One-shot completion (ignores history) ---------------------------- #
    def complete(self, prompt: str | ChatMessage) -> ChatCompletion:
        """Run *prompt* outside the conversation (history is untouched)."""
        single = ChatMessage(prompt) if isinstance(prompt, str) else prompt
        conversation = [single]
        self._trim_conversation(conversation)
        return self._chat_completion(conversation)

    # -------------------------- internals ----------------------------- #
    # Trim conversation to honour limits and add personality ~~~~~~~~~~~ #
    def _trim_conversation(self, messages: List[ChatMessage]) -> None:
        """Mutate *messages* so it respects configured limits."""
        # Remove leading tool-results without matching calls
        while messages and messages[0].has_tool_call_results():
            messages.pop(0)

        # Enforce max steps
        if len(messages) > self.max_conversation_steps:
            del messages[: len(messages) - self.max_conversation_steps]

        if not messages:
            raise ValueError("No messages left in conversation after trimming")

        # Inject personality (developer role) as first message
        if self.personality:
            messages.insert(0, ChatMessage(self.personality, ChatMessage.Author.DEVELOPER))

    # Convert ChatMessage → OpenAI message dict ~~~~~~~~~~~~~~~~~~~~~~~~ #
    def _from_chat_message(self, msg: ChatMessage) -> List[Dict[str, Any]]:
        if msg.has_tool_calls():
            tool_calls = []
            for call in msg.get_tool_calls():
                tool_calls.append(
                    {
                        "id": call.id,
                        "type": "function",
                        "function": {
                            "name": call.tool.id,
                            "arguments": json.dumps(call.arguments, separators=(",", ":")),
                        },
                    }
                )
            return [{"role": "assistant", "content": None, "tool_calls": tool_calls}]

        if msg.has_tool_call_results():
            return [
                {
                    "role": "tool",
                    "tool_call_id": r.tool_call_id,
                    "content": r.result,
                }
                for r in msg.get_tool_call_results()
            ]

        # Plain text
        if not msg.is_text():
            raise ValueError("Message must be text, a tool call, or tool call results")

        role_map = {
            ChatMessage.Author.USER: "user",
            ChatMessage.Author.BOT: "assistant",
            ChatMessage.Author.DEVELOPER: "system",  # OpenAI 'developer' maps to 'system'
        }
        return [{"role": role_map[msg.author], "content": msg.get_text_content()}]

    # Convert OpenAI message → ChatMessage ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    def _from_openai_message(self, message: Mapping[str, Any]) -> ChatMessage:
        if "tool_calls" in message:
            calls: List[ToolCall] = []
            for tc in message["tool_calls"]:
                tool_id = tc["function"]["name"]
                tool = self._tool_map.get(tool_id)
                if tool is None:
                    raise ValueError(f"No tool registered with id '{tool_id}'")

                calls.append(
                    ToolCall(
                        id_=tc["id"],
                        tool=tool,
                        arguments=json.loads(tc["function"]["arguments"]),
                    )
                )
            return ChatMessage(ChatMessage.Author.BOT, calls)

        parts: List[TextPart] = []
        if content := message.get("content"):
            parts.append(TextPart(str(content)))
        if message.get("role") == "assistant" and message.get("content") is None:
            parts.append(TextPart("**The model generated an empty response**"))

        return ChatMessage(ChatMessage.Author.BOT, parts)

    # Prepare response_format / tools for OpenAI call ~~~~~~~~~~~~~~~~~~ #
    def _create_response_format(self) -> Dict[str, Any] | None:
        if self._response_format is None:
            return None
        return {
            "type": "json_object",
            "schema": json.loads(self._response_format),
        }

    def _create_tool_definitions(self) -> List[Dict[str, Any]] | None:
        if not self._tool_map:
            return None
        tools = []
        for t in self._tool_map.values():
            tools.append(
                {
                    "type": "function",
                    "function": {
                        "name": t.id,
                        "description": t.description,
                        "parameters": json.loads(t.json_parameters),
                    },
                }
            )
        return tools

    # Core: call OpenAI and wrap result ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    def _chat_completion(self, messages: Sequence[ChatMessage]) -> ChatCompletion:
        openai_messages: List[Dict[str, Any]] = []
        for m in messages:
            openai_messages.extend(self._from_chat_message(m))

        req: Dict[str, Any] = {
            "model": self.model,
            "messages": openai_messages,
            "temperature": self.temperature,
        }

        if (rf := self._create_response_format()) is not None:
            req["response_format"] = rf
        if (td := self._create_tool_definitions()) is not None:
            req["tools"] = td

        logger.info("OpenAI request: %s", req)

        resp = openai.ChatCompletion.create(**req)
        choice = resp.choices[0]
        finish_reason = self._map_finish_reason(choice.finish_reason)

        chat_message = self._from_openai_message(choice.message)
        return ChatCompletion(finish_reason, chat_message)

    # Finish-reason mapping ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
    @staticmethod
    def _map_finish_reason(finish: str | None) -> ChatCompletion.FinishReason:
        mapping = {
            "stop": ChatCompletion.FinishReason.COMPLETED,
            "tool_calls": ChatCompletion.FinishReason.COMPLETED,
            "function_call": ChatCompletion.FinishReason.COMPLETED,
            "length": ChatCompletion.FinishReason.TRUNCATED,
            "content_filter": ChatCompletion.FinishReason.INAPPROPRIATE,
        }
        return mapping.get(finish, ChatCompletion.FinishReason.OTHER)

	# Finish-reason mapping ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #      
    @staticmethod
    def fill_slots(template: str, slots: Mapping[str, Any]) -> str:  
        """
        Replace every ``{{key}}`` in *template* with the corresponding value
        from *slots*. Unknown keys are left untouched; *None* is replaced by
        the empty string.

        Parameters
        ----------
        template : str
            A string containing ``{{placeholders}}``.
        slots : Mapping[str, Any]
            Values to inject into the template.

        Returns
        -------
        str
            The rendered string.
        """
        if template is None:
            raise ValueError("template must not be None")
        if slots is None:
            raise ValueError("slots must not be None")

        def _sub(match: re.Match[str]) -> str:
            key = match.group(1).strip()
            value = slots.get(key)
            return "" if value is None else str(value)

        return re.sub(r"\{\{([^}]+)\}\}", _sub, template)
        
    # --------------------------- teardown ----------------------------- #
    def close(self) -> None:
        """Close all tools; nothing required for *openai* client."""
        for tool in self._tool_map.values():
            try:
                tool.close()
            except Exception:  # noqa: BLE001
                logger.exception("Error while closing tool %s", tool.id)


##  react_step.py
from __future__ import annotations

import logging
from enum import Enum
from typing import List, Self

from pydantic import BaseModel, Field, model_validator

# --------------------------------------------------------------------------- #
# Logging configuration (equivalent to Java SimpleLogger)
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


class Status(str, Enum):
    """Execution status for a ReAct step."""

    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    ERROR = "ERROR"


class Step(BaseModel):
    """
    Python equivalent of `ReactAgent.Step`.

    Fields
    ------
    status       : optional execution status.
    actor        : identifier of the agent/tool performing the step.
    thought      : reasoning for this step.
    observation  : outcome, error details, or any additional data.
    """

    status: Status | None = Field(
        default=None,
        description=(
            "If you finish the execution or experience an unrecoverable error, "
            "set this to either COMPLETED or ERROR respectively."
        ),
    )
    actor: str = Field(..., description="The tool or agent that executed this step.")
    thought: str = Field(
        ...,
        description="Your reasoning about why and how you accomplish this step.",
    )
    observation: str = Field(
        ...,
        description="Any additional data, like step outcomes, error messages, etc.",
    )

    # ------------------------------------------------------------------ #
    # Fluent builder pattern
    # ------------------------------------------------------------------ #
    class Builder:
        def __init__(self) -> None:
            self._status: Status | None = None
            self._actor: str | None = None
            self._thought: str | None = None
            self._observation: str | None = None

        # --- fluent setters ------------------------------------------- #
        def status(self, status: Status) -> Self:  # noqa: D401
            self._status = status
            return self

        def actor(self, actor: str) -> Self:  # noqa: D401
            if actor is None:
                raise ValueError("actor must not be None")
            self._actor = actor
            return self

        def thought(self, thought: str) -> Self:  # noqa: D401
            if thought is None:
                raise ValueError("thought must not be None")
            self._thought = thought
            return self

        def observation(self, observation: str) -> Self:  # noqa: D401
            if observation is None:
                raise ValueError("observation must not be None")
            self._observation = observation
            return self

        # --- build ----------------------------------------------------- #
        def build(self) -> "Step":
            return Step(
                status=self._status,
                actor=self._actor or self._raise("actor"),
                thought=self._thought or self._raise("thought"),
                observation=self._observation or self._raise("observation"),
            )

        # --- helpers --------------------------------------------------- #
        @staticmethod
        def _raise(field_name: str) -> None:
            raise ValueError(f"{field_name} must not be None")

    # Provide static factory for parity with Java
    @staticmethod
    def builder() -> "Step.Builder":
        return Step.Builder()


class ToolCallStep(Step):
    """
    Python equivalent of `ReactAgent.ToolCallStep`, extending `Step`.
    """

    action: str = Field(
        ...,
        description="The action that was taken at this step. Typically a tool invocation.",
    )
    action_input: str = Field(
        ...,
        alias="action_input",
        description="Input for the action.",
    )
    action_steps: List[Step] = Field(
        default_factory=list,
        alias="action_steps",
        description=(
            "If the action was delegated to another agent, this is the list "
            "of steps that agent performed."
        ),
    )

    # ------------------------------------------------------------------ #
    # Fluent builder pattern
    # ------------------------------------------------------------------ #
    class Builder(Step.Builder):
        def __init__(self) -> None:
            super().__init__()
            self._action: str | None = None
            self._action_input: str | None = None
            self._action_steps: List[Step] = []

        # --- fluent setters ------------------------------------------- #
        def action(self, action: str) -> Self:  # noqa: D401
            if action is None:
                raise ValueError("action must not be None")
            self._action = action
            return self

        def action_input(self, action_input: str) -> Self:  # noqa: D401
            if action_input is None:
                raise ValueError("action_input must not be None")
            self._action_input = action_input
            return self

        def action_steps(self, steps: List[Step]) -> Self:  # noqa: D401
            self._action_steps = list(steps)
            return self

        def add_step(self, step: Step) -> Self:  # noqa: D401
            self._action_steps.append(step)
            return self

        # --- build ----------------------------------------------------- #
        def build(self) -> "ToolCallStep":
            return ToolCallStep(
                status=self._status,
                actor=self._actor or self._raise("actor"),
                thought=self._thought or self._raise("thought"),
                observation=self._observation or self._raise("observation"),
                action=self._action or self._raise("action"),
                action_input=self._action_input or self._raise("action_input"),
                action_steps=self._action_steps,
            )

    # Provide static factory for parity with Java
    @staticmethod
    def builder() -> "ToolCallStep.Builder":
        return ToolCallStep.Builder()

    # ------------------------------------------------------------------ #
    # Ensure alias names work both ways
    # ------------------------------------------------------------------ #
    model_config = {"populate_by_name": True}

    # ------------------------------------------------------------------ #
    # Validation to keep `status` optional but consistent
    # ------------------------------------------------------------------ #
    @model_validator(mode="after")
    def _check_required(cls, values):  # noqa: N805
        # actor, thought, observation, action, action_input are ensured by Pydantic
        return values

## react_agent.py

from __future__ import annotations

import logging
from typing import List, Sequence, TYPE_CHECKING

from pydantic import BaseModel, Field

from agent import Agent
from tool import Tool
from steps import Step  # Step and ToolCallStep are already provided

if TYPE_CHECKING:  # avoid circular imports at runtime
    from executor_module import ExecutorModule
    from critic_module import CriticModule


# --------------------------------------------------------------------------- #
# Logging configuration (equivalent to Java SimpleLogger)
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


class ReactAgent(Agent):
    """
    Python port of the Java `ReactAgent`.

    A ReAct agent is composed of:
      • an *executor* module in charge of reasoning/acting with tools;
      • a *reviewer* (critic) module that audits the executor’s decisions.

    Only the *executor* receives the tool list; the wrapper itself does **not**
    expose tools directly.
    """

    DEFAULT_MODEL: str = "gpt-4.1"

    # --------------------------------------------------------------------- #
    # Nested helper - Parameters (for tools that wrap the agent)
    # --------------------------------------------------------------------- #
    class Parameters(BaseModel):
        """
        Base parameters for any tool available to a ReAct agent.

        This mirrors the static `Parameters` class defined in the Java version.
        """

        thought: str = Field(
            ...,
            description="Your reasoning about why this tool has been called.",
        )

    # --------------------------------------------------------------------- #
    # Construction
    # --------------------------------------------------------------------- #
    def __init__(
        self,
        id_: str,
        description: str,
        tools: Sequence[Tool],
        check_last_step: bool = True,
    ) -> None:
        # --- null-checks (mirrors @NonNull) --------------------------------
        if id_ is None:
            raise ValueError("id_ must not be None")
        if description is None:
            raise ValueError("description must not be None")
        if tools is None:
            raise ValueError("tools must not be None")

        # Initialise the outer Agent **without** tools (only executor uses them)
        super().__init__(id_=id_, description=description, tools=[])

        # Model configuration mirrors the Java defaults
        self.model = self.DEFAULT_MODEL
        self.temperature = 0.0

        # Additional context / few-shot examples the caller can set
        self._context: str = ""
        self._examples: str = ""

        # Create the inner modules (executor & critic).  They are imported
        # lazily to avoid circular-import issues.
        from executor_module import ExecutorModule  # local import
        from critic_module import CriticModule

        self._executor: ExecutorModule = ExecutorModule(
            agent=self,
            tools=list(tools),
            check_last_step=check_last_step,
            model=self.DEFAULT_MODEL,
        )
        self._reviewer: CriticModule = CriticModule(
            agent=self,
            tools=list(tools),
            model=self.DEFAULT_MODEL,
        )

    # --------------------------------------------------------------------- #
    # Public API mirroring Java implementation
    # --------------------------------------------------------------------- #
    # Properties ----------------------------------------------------------- #
    @property
    def context(self) -> str:
        return self._context

    @context.setter
    def context(self, value: str) -> None:
        if value is None:
            raise ValueError("context must not be None")
        self._context = value

    @property
    def examples(self) -> str:
        return self._examples

    @examples.setter
    def examples(self, value: str) -> None:
        if value is None:
            raise ValueError("examples must not be None")
        self._examples = value

    # Accessors for inner modules (read-only) ------------------------------ #
    @property
    def executor(self):  # → ExecutorModule
        return self._executor

    @property
    def reviewer(self):  # → CriticModule
        return self._reviewer

    # Delegated behaviour -------------------------------------------------- #
    def execute(self, command: str) -> Step:
        """
        Execute *command* through the underlying executor module and
        return the final `Step`.
        """
        if command is None:
            raise ValueError("command must not be None")
        logger.info("Executing command: %s", command)
        return self._executor.execute(command)

    def get_steps(self) -> List[Step]:
        """Expose the list of execution steps gathered by the executor."""
        return self._executor.steps

## critic_module.py

from __future__ import annotations

import logging
from typing import List, Mapping

from agent import Agent
from json_schema import JsonSchema
from react_agent import ReactAgent
from steps import Step, ToolCallStep
from tool import Tool

# --------------------------------------------------------------------------- #
# Logging configuration (equivalent to Java SimpleLogger)
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


class CriticModule(Agent):
    """
    Critic component of a `ReactAgent`.

    It reviews the executor’s actions and suggests improvements when necessary.
    """

    # --------------------------------------------------------------------- #
    # Prompt templates
    # --------------------------------------------------------------------- #
    _PROMPT_TEMPLATE: str = (
        "# Identity\n\n"
        "You are a reviewer agent; your task is to monitor how an executor agent "
        "tries to execute user's commands and provide suggestion to improve execution.\n"
        "The specific user's command the executor is trying to execute is provided "
        "in the below <user_command> tag.\n"
        "\n<user_command>\n{{command}}\n</user_command>\n\n"
        "You will be provided by the user with a potentially empty list of execution "
        "steps, in <steps> tag, that have been already performed by the executor in "
        "its attempt to execute the user's command. The format of these steps is "
        "provided as a JSON schema in <step_format> tag below. In these steps, the "
        'executor agent is identified with actor=="{{executor_id}}".\n'
        "\n<step_format>\n"
        + JsonSchema.get_json_schema(ToolCallStep) +
        "\n</step_format>\n\n"
        "\n# Additional Context and Information\n\n"
        "  * In order to execute the command, the executor agent has the tools "
        "described in the below <tools> tag at its disposal:\n\n"
        "<tools>\n{{tools}}\n</tools>\n\n"
        "{{context}}\n"
    )

    _REVIEW_TOOL_CALL_TEMPLATE: str = (
        _PROMPT_TEMPLATE
        + "\n# Instructions\n\n"
        "  * If the steps contain evidence that the executor entered a loop calling "
        "the same tool repeatedly with identical parameters, suggest strictly calling "
        "another tool for the next step.\n"
        "  * If and only if the last step contains a tool call that resulted in an "
        "error, inspect the tool definition and check for missing or unsupported "
        "parameters; attempt to retrieve missing parameter values from previous "
        'steps’ "observation" fields. Suggest repeating the call with the recovered '
        "values and flag unsupported parameters.\n"
        '  * **IMPORTANT** In every other case, or when no relevant advice applies, '
        'output exactly "CONTINUE". Do not add comments when outputting "CONTINUE", '
        "and do not output \"CONTINUE\" when you have a suggestion."
    )

    _REVIEW_CONCLUSIONS_TEMPLATE: str = (
        _PROMPT_TEMPLATE
        + "\n# Instructions\n\n"
        '  * If, and only if, the last step has status="ERROR", carefully inspect all '
        "steps to identify the root cause and provide a remediation suggestion.\n"
        '  * If, and only if, the last step has status="COMPLETED", verify through '
        '"observation" or "thought" fields that no further work is pending; if more '
        "actions are required, suggest those actions.\n"
        '  * **IMPORTANT** In every other scenario, or when no advice is relevant, '
        'output exactly "CONTINUE". Do not add comments when outputting "CONTINUE".\n'
        '  * Consider a tool invocation valid evidence only when an "action" field '
        "explicitly references a tool; ignore claims in \"thought\" or \"observation\" "
        "that are not backed by such evidence.\n"
        "{{examples}}\n"
    )

    # --------------------------------------------------------------------- #
    # Constructor
    # --------------------------------------------------------------------- #
    def __init__(
        self,
        agent: ReactAgent,
        tools: List[Tool],
        model: str,
    ) -> None:
        if agent is None:
            raise ValueError("agent must not be None")
        if tools is None:
            raise ValueError("tools must not be None")
        if model is None:
            raise ValueError("model must not be None")

        # The critic does not call any tool, therefore `tools=[]`
        super().__init__(
            id_=f"{agent.id}-critic",
            description=f"Critic module for {agent.id} agent",
            tools=[],
        )
        self._agent: ReactAgent = agent
        self._tools: List[Tool] = list(tools)

        self.temperature = 0.0
        self.model = model

    # ------------------------------------------------------------------ #
    # Read-only properties
    # ------------------------------------------------------------------ #
    @property
    def agent(self) -> ReactAgent:  # noqa: D401
        """Return the parent `ReactAgent`."""
        return self._agent

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def review_tool_call(self, steps: List[Step]) -> str:
        """Review the latest tool call performed by the executor."""
        return self._review(self._REVIEW_TOOL_CALL_TEMPLATE, steps)

    def review_conclusions(self, steps: List[Step]) -> str:
        """Review the executor’s final conclusions."""
        return self._review(self._REVIEW_CONCLUSIONS_TEMPLATE, steps)

    # ------------------------------------------------------------------ #
    # Internal logic
    # ------------------------------------------------------------------ #
    def _review(self, template: str, steps: List[Step]) -> str:
        if steps is None:
            raise ValueError("steps must not be None")

        # Prepare placeholders for the prompt
        mapping: Mapping[str, str] = {
            "command": self._agent.executor.command,
            "executor_id": self._agent.executor.id,
            "context": self._agent.context,
            "tools": self._build_tool_description(self._tools),
            "steps": JsonSchema.serialize(steps),
        }

        # Set critic personality
        self.personality = Agent.fill_slots(template, mapping)

        # As in Java: send the same message twice
        self.clear_conversation()
        prompt = Agent.fill_slots("<steps>\n{{steps}}\n</steps>", mapping)
        suggestion = self.chat(prompt).get_text()
        logger.debug("**** Suggestion: %s", suggestion)

        # Second call (mirrors original behaviour)
        return self.chat(prompt).get_text()

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    @staticmethod
    def _build_tool_description(tools: List[Tool]) -> str:
        """
        Build a human-readable description of the tools available to the executor.
        """
        sections: List[str] = []
        for tool in tools:
            sections.extend(
                [
                    "## Tool\n\n",
                    f"### Tool ID: {tool.id}\n",
                    "### Tool Description\n",
                    f"{tool.description}\n",
                    "### Tool Parameters (as JSON schema)\n",
                    f"{tool.json_parameters}\n\n",
                ]
            )
        return "".join(sections)
        
# executor_module.py

from __future__ import annotations

import logging
import json
from typing import Any, Dict, List, Mapping, Sequence, TYPE_CHECKING

from agent import Agent
from chat_types import ChatCompletion, ChatMessage, ToolCall, ToolCallResult, TextPart
from json_schema import JsonSchema
from steps import Step, ToolCallStep, Status
from tool import Tool

if TYPE_CHECKING:  # circular-import guards
    from react_agent import ReactAgent
    from critic_module import CriticModule

# --------------------------------------------------------------------------- #
# Logging configuration (equivalent to Java SimpleLogger)
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


# --------------------------------------------------------------------------- #
# ExecutorModule ­– executes the user command through reasoning & tools
# --------------------------------------------------------------------------- #
class ExecutorModule(Agent):
    """
    Executor component of a :class:`react_agent.ReactAgent`.

    It plans and carries out the steps needed to fulfil a user command,
    leveraging the tools provided by the parent *ReactAgent*.
    """

    # ------------------------------------------------------------------ #
    # Constants
    # ------------------------------------------------------------------ #
    MAX_STEPS: int = 40  # hard stop to avoid infinite loops

    _PROMPT_TEMPLATE: str = (
        "# Identity\n\n"
        "You are a ReAct (Reasoning and Acting) agent; your task is to execute "
        "the below user command in <user_command> tag.\n"
        "\n<user_command>\n{{command}}\n</user_command>\n\n"
        "You will be provided by the user with a potentially empty list of execution "
        "steps, in <steps> tag, that you have already performed in an attempt to "
        "execute the user's command. The format of these steps is provided as a JSON "
        "schema in <step_format> tag below.\n"
        "\n<step_format>\n"
        + JsonSchema.get_json_schema(ToolCallStep)
        + "\n</step_format>\n\n"
        "Together with the list of steps, the user might provide a suggestion about "
        "how to execute the next step.\n"
        "\n# Additional Context and Information\n\n"
        " * You are identified with actor=={{id}} in execution steps."
        "{{context}}\n\n"
        "\n# Instructions\n\n"
        "  * Carefully plan the steps required to execute the user's command, think "
        "it step by step.\n"
        "  * If the user provided a suggestion about how to progress execution, then "
        "**STRICTLY** follow that suggestion when planning the next step. The "
        "suggestion applies only to the very next step.\n"
        "  * At each step use the most suitable tool at your disposal. **NEVER** "
        "output a step to *describe* a tool call – call the tool directly.\n"
        "  * Your tools have no access to <steps>; therefore pass every required "
        "parameter explicitly.\n"
        "  * When you are completely done, output a final step with status="
        "\"COMPLETED\". Do **NOT** output status=\"COMPLETED\" if work remains.\n"
        "  * If you encounter an unrecoverable error, output a final step with "
        "status=\"ERROR\" and provide a detailed explanation in the \"observation\" "
        "field. Otherwise use status=\"IN_PROGRESS\" sparingly.\n"
        "  * The final step **MUST** match the JSON schema in <output_schema>.\n"
        "\n<output_schema>\n"
        + JsonSchema.get_json_schema(Step)
        + "\n</output_schema>\n"
        "\n## Other Examples\n\n"
        "{{examples}}\n"
    )

    # ------------------------------------------------------------------ #
    # Construction
    # ------------------------------------------------------------------ #
    def __init__(
        self,
        agent: "ReactAgent",
        tools: Sequence[Tool],
        check_last_step: bool,
        model: str,
    ) -> None:
        if agent is None:
            raise ValueError("agent must not be None")
        if tools is None:
            raise ValueError("tools must not be None")
        if model is None:
            raise ValueError("model must not be None")

        super().__init__(
            id_=f"{agent.id}-executor",
            description=f"Executor module for {agent.id} agent",
            tools=list(tools),
        )

        self._agent: ReactAgent = agent
        self._check_last_step: bool = bool(check_last_step)

        # Runtime state
        self._command: str | None = None
        self._steps: List[Step] = []

        # Model configuration
        self.temperature = 0.0
        self.model = model
        self.set_response_format(Step)

    # ----------------------------- props ------------------------------- #
    @property
    def agent(self) -> "ReactAgent":  # noqa: D401
        return self._agent

    @property
    def check_last_step(self) -> bool:  # noqa: D401
        return self._check_last_step

    @property
    def command(self) -> str | None:  # noqa: D401
        return self._command

    # Steps list (read-only) ------------------------------------------- #
    @property
    def steps(self) -> List[Step]:  # noqa: D401
        return self._steps

    # Convenience ------------------------------------------------------- #
    def get_last_step(self) -> Step | None:
        return self._steps[-1] if self._steps else None

    def add_step(self, step: Step) -> None:
        self._steps.append(step)
        # TODO: persist step to external storage if required
        logger.info(JsonSchema.serialize(step))

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def execute(self, command: str) -> Step:
        """
        Execute *command* and return the final :class:`steps.Step`.
        """
        if command is None:
            raise ValueError("command must not be None")

        self._command = command
        self._steps.clear()

        # ---------------- build persona -------------------------------- #
        slots: Mapping[str, str] = {
            "command": command,
            "id": self.id,
            "context": self.agent.context,
            "examples": self.agent.examples,
        }
        self.personality = Agent.fill_slots(self._PROMPT_TEMPLATE, slots)

        # ---------------- first bookkeeping step ----------------------- #
        first_step = (
            Step.builder()
            .actor(self.id)
            .status(Status.IN_PROGRESS)
            .thought(
                Agent.fill_slots(
                    (
                        "I am starting execution of the below user's command in "
                        "<user_command>\n\n<user_command>\n{{command}}\n</user_command>"
                    ),
                    slots,
                )
            )
            .observation("Execution just started.")
            .build()
        )
        self.add_step(first_step)

        # ---------------- execution loop ------------------------------- #
        suggestion: str = (
            "No suggestions. Proceed as you see best, using the tools at your disposal."
        )
        instructions_tpl: str = "<steps>\n{{steps}}\n</steps>\n\nSuggestion: {{suggestion}}"

        while (
            len(self._steps) < self.MAX_STEPS
            and (
                self.get_last_step() is None
                or self.get_last_step().status is None
                or self.get_last_step().status == Status.IN_PROGRESS
            )
        ):
            # ---- prepare prompt -------------------------------------- #
            self.clear_conversation()
            steps_json = json.dumps(
                [
                    s.model_dump(exclude={"action_steps"})
                    if isinstance(s, ToolCallStep)
                    else s.model_dump()
                    for s in self._steps
                ],
                separators=(",", ":"),
            )
            prompt_slots = {
                **slots,
                "steps": steps_json,
                "suggestion": suggestion,
            }
            prompt = Agent.fill_slots(instructions_tpl, prompt_slots)

            # ---- call the LLM ---------------------------------------- #
            try:
                reply = self.chat(prompt)
            except Exception as exc:  # LLM invocation failed
                error_step = (
                    ToolCallStep.builder()
                    .actor(self.id)
                    .status(Status.ERROR)
                    .thought("I had something in mind...")
                    .action("LLM was called but this resulted in an error.")
                    .action_input(prompt)
                    .action_steps([])
                    .observation(str(exc))
                    .build()
                )
                self.add_step(error_step)
                break

            if reply.finish_reason != ChatCompletion.FinishReason.COMPLETED:
                truncated_step = (
                    ToolCallStep.builder()
                    .actor(self.id)
                    .status(Status.ERROR)
                    .thought("I had something in mind...")
                    .action("LLM was called but this resulted in a truncated message.")
                    .action_input(prompt)
                    .action_steps([])
                    .observation(f"Response finish reason: {reply.finish_reason}")
                    .build()
                )
                self.add_step(truncated_step)
                break

            # ---- process LLM output ---------------------------------- #
            if reply.message.has_tool_calls():  # the model invoked tools
                with_error = False
                for call in reply.message.get_tool_calls():
                    try:
                        result = call.execute()
                    except Exception as exc:  # tool raised
                        result = ToolCallResult.from_exception(call, exc)
                        with_error = True
                    else:
                        with_error |= (
                            isinstance(result.result, str)
                            and "error" in result.result.lower()
                        )

                    # store step
                    args_no_thought = dict(call.arguments)
                    thought = args_no_thought.pop("thought", "No thought passed explicitly.")
                    call_step = (
                        ToolCallStep.builder()
                        .actor(self.id)
                        .status(Status.IN_PROGRESS)
                        .thought(str(thought))
                        .action(f'The tool "{call.tool.id}" has been called')
                        .action_input(JsonSchema.serialize(args_no_thought))
                        .action_steps(
                            call.tool.agent.get_steps()  # type: ignore[attr-defined]
                            if hasattr(call.tool, "agent") and isinstance(call.tool.agent, ReactAgent)
                            else []
                        )
                        .observation(str(result.result))
                        .build()
                    )
                    self.add_step(call_step)

                    if len(self._steps) > self.MAX_STEPS:
                        break

                # ask critic if needed
                if len(self._steps) <= self.MAX_STEPS:
                    suggestion = (
                        self.agent.reviewer.review_tool_call(self._steps)
                        if with_error
                        else "CONTINUE"
                    )
            else:  # plain text → expect JSON step
                try:
                    step_obj = reply.get_object(Step)
                    step_obj.actor = self.id  # enforce correct actor
                    self.add_step(step_obj)
                except Exception as exc:  # JSON parsing failed
                    fallback = (
                        Step.builder()
                        .actor(self.id)
                        .status(Status.ERROR)
                        .thought(f"I stopped because I encountered this error: {exc}")
                        .observation(reply.get_text())
                        .build()
                    )
                    self.add_step(fallback)

                # decide next suggestion
                if self.get_last_step().status == Status.IN_PROGRESS:
                    suggestion = "**STRICTLY** proceed with next steps, by calling appropriate tools."
                elif self._check_last_step:
                    suggestion = self.agent.reviewer.review_conclusions(self._steps)
                    if "continue" not in suggestion.lower():
                        # force continuation
                        self.get_last_step().status = Status.IN_PROGRESS

        # ---------------- loop finished ------------------------------- #
        if len(self._steps) >= self.MAX_STEPS:
            overflow_step = (
                Step.builder()
                .actor(self.id)
                .status(Status.ERROR)
                .thought(
                    f"Execution was stopped because it exceeded maximum number of steps "
                    f"({self.MAX_STEPS})."
                )
                .observation("I probably entered some kind of loop.")
                .build()
            )
            self.add_step(overflow_step)
            logger.error("Maximum steps exceeded; aborting execution.")

        return self.get_last_step()  # type: ignore[return-value]

# toolable_react_agent.py

from __future__ import annotations

import logging
from typing import Sequence

from pydantic import Field

from agent import Agent  # for type hints only
from react_agent import ReactAgent
from steps import Step, Status
from tool import AbstractTool, Tool, ToolCall, ToolCallResult

# ---------------------------------------------------------------------------#
# Logging configuration (Java-style simple logger)
# ---------------------------------------------------------------------------#
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------#
# ToolableReactAgent
# ---------------------------------------------------------------------------#
class ToolableReactAgent(ReactAgent, AbstractTool):
    """
    A `ReactAgent` that can be used as a `Tool` by another agent.

    It inherits behaviour from both `ReactAgent` (conversation logic) and
    `AbstractTool` (tool life-cycle & helpers).
    """

    # --------------------------- parameters --------------------------- #
    class Parameters(ReactAgent.Parameters):
        """JSON-serialisable parameters for invoking the tool."""

        question: str = Field(
            ...,
            description=(
                "A question that this tool must answer or a command it must execute."
            ),
        )

    # ----------------------------- init ------------------------------- #
    def __init__(
        self,
        id_: str,
        description: str,
        tools: Sequence[Tool],
        check_last_step: bool = True,
    ) -> None:
        # Initialise the ReactAgent part (handles reasoning & tools)
        ReactAgent.__init__(
            self,
            id_=id_,
            description=description,
            tools=tools,
            check_last_step=check_last_step,
        )

        # Initialise the AbstractTool part (exposes tool metadata)
        AbstractTool.__init__(
            self,
            id_=id_,
            description=description,
            parameters_cls=ToolableReactAgent.Parameters,
        )

    # --------------------------- overrides ---------------------------- #
    def invoke(self, call: ToolCall) -> ToolCallResult:  # noqa: D401
        """
        Execute the wrapped ReAct agent to answer *question*.

        The `question` parameter is mandatory; errors are returned in
        `ToolCallResult` following the Java semantics.
        """
        if not self.is_initialized():
            raise RuntimeError("Tool must be initialized before invocation.")

        question = self.get_string("question", call.arguments)
        if question is None:
            return ToolCallResult.from_call(
                call,
                'ERROR: You must provide a command to execute as "question" parameter.',
            )

        # Delegate to the executor module of the underlying ReactAgent
        result_step: Step = self.execute(question)

        if result_step.status == Status.ERROR:
            return ToolCallResult.from_call(call, f"ERROR: {result_step.observation}")

        return ToolCallResult.from_call(call, result_step.observation)

    # ------------------------------------------------------------------ #
    # Clean-up
    # ------------------------------------------------------------------ #
    def close(self) -> None:
        """Close both the tool and the underlying agent."""
        AbstractTool.close(self)
        ReactAgent.close(self)

</python>